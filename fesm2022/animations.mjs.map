{"version":3,"file":"animations.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/animations/src/animation_builder.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  ANIMATION_MODULE_TYPE,\n  DOCUMENT,\n  Inject,\n  inject,\n  Injectable,\n  Renderer2,\n  RendererFactory2,\n  RendererType2,\n  ViewEncapsulation,\n  ɵAnimationRendererType as AnimationRendererType,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {AnimationMetadata, AnimationOptions, sequence} from './animation_metadata';\nimport {RuntimeErrorCode} from './errors';\nimport {AnimationPlayer} from './players/animation_player';\n\n/**\n * An injectable service that produces an animation sequence programmatically within an\n * Angular component or directive.\n * Provided by the `BrowserAnimationsModule` or `NoopAnimationsModule`.\n *\n * @usageNotes\n *\n * To use this service, add it to your component or directive as a dependency.\n * The service is instantiated along with your component.\n *\n * Apps do not typically need to create their own animation players, but if you\n * do need to, follow these steps:\n *\n * 1. Use the <code>[AnimationBuilder.build](api/animations/AnimationBuilder#build)()</code> method\n * to create a programmatic animation. The method returns an `AnimationFactory` instance.\n *\n * 2. Use the factory object to create an `AnimationPlayer` and attach it to a DOM element.\n *\n * 3. Use the player object to control the animation programmatically.\n *\n * For example:\n *\n * ```ts\n * // import the service from BrowserAnimationsModule\n * import {AnimationBuilder} from '@angular/animations';\n * // require the service as a dependency\n * class MyCmp {\n *   constructor(private _builder: AnimationBuilder) {}\n *\n *   makeAnimation(element: any) {\n *     // first define a reusable animation\n *     const myAnimation = this._builder.build([\n *       style({ width: 0 }),\n *       animate(1000, style({ width: '100px' }))\n *     ]);\n *\n *     // use the returned factory object to create a player\n *     const player = myAnimation.create(element);\n *\n *     player.play();\n *   }\n * }\n * ```\n *\n * @publicApi\n *\n * @deprecated 20.2 Use `animate.enter` or `animate.leave` instead. Intent to remove in v23\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(BrowserAnimationBuilder)})\nexport abstract class AnimationBuilder {\n  /**\n   * Builds a factory for producing a defined animation.\n   * @param animation A reusable animation definition.\n   * @returns A factory object that can create a player for the defined animation.\n   * @see {@link animate}\n   */\n  abstract build(animation: AnimationMetadata | AnimationMetadata[]): AnimationFactory;\n}\n\n/**\n * A factory object returned from the\n * <code>[AnimationBuilder.build](api/animations/AnimationBuilder#build)()</code>\n * method.\n *\n * @publicApi\n *\n * @deprecated 20.2 Use `animate.enter` or `animate.leave` instead. Intent to remove in v23\n */\nexport abstract class AnimationFactory {\n  /**\n   * Creates an `AnimationPlayer` instance for the reusable animation defined by\n   * the <code>[AnimationBuilder.build](api/animations/AnimationBuilder#build)()</code>\n   * method that created this factory and attaches the new player a DOM element.\n   *\n   * @param element The DOM element to which to attach the player.\n   * @param options A set of options that can include a time delay and\n   * additional developer-defined parameters.\n   */\n  abstract create(element: any, options?: AnimationOptions): AnimationPlayer;\n}\n\n@Injectable({providedIn: 'root'})\nexport class BrowserAnimationBuilder extends AnimationBuilder {\n  private animationModuleType = inject(ANIMATION_MODULE_TYPE, {optional: true});\n  private _nextAnimationId = 0;\n  private _renderer: Renderer2;\n\n  constructor(rootRenderer: RendererFactory2, @Inject(DOCUMENT) doc: Document) {\n    super();\n    const typeData: RendererType2 = {\n      id: '0',\n      encapsulation: ViewEncapsulation.None,\n      styles: [],\n      data: {animation: []},\n    };\n    this._renderer = rootRenderer.createRenderer(doc.body, typeData);\n\n    if (this.animationModuleType === null && !isAnimationRenderer(this._renderer)) {\n      // We only support AnimationRenderer & DynamicDelegationRenderer for this AnimationBuilder\n\n      throw new RuntimeError(\n        RuntimeErrorCode.BROWSER_ANIMATION_BUILDER_INJECTED_WITHOUT_ANIMATIONS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. ' +\n            'Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.',\n      );\n    }\n  }\n\n  override build(animation: AnimationMetadata | AnimationMetadata[]): AnimationFactory {\n    const id = this._nextAnimationId;\n    this._nextAnimationId++;\n    const entry = Array.isArray(animation) ? sequence(animation) : animation;\n    issueAnimationCommand(this._renderer, null, id, 'register', [entry]);\n    return new BrowserAnimationFactory(id, this._renderer);\n  }\n}\n\nclass BrowserAnimationFactory extends AnimationFactory {\n  constructor(\n    private _id: number,\n    private _renderer: Renderer2,\n  ) {\n    super();\n  }\n\n  override create(element: any, options?: AnimationOptions): AnimationPlayer {\n    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);\n  }\n}\n\nclass RendererAnimationPlayer implements AnimationPlayer {\n  public parentPlayer: AnimationPlayer | null = null;\n  private _started = false;\n\n  constructor(\n    public id: number,\n    public element: any,\n    options: AnimationOptions,\n    private _renderer: Renderer2,\n  ) {\n    this._command('create', options);\n  }\n\n  private _listen(eventName: string, callback: (event: any) => any): () => void {\n    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);\n  }\n\n  private _command(command: string, ...args: any[]): void {\n    issueAnimationCommand(this._renderer, this.element, this.id, command, args);\n  }\n\n  onDone(fn: () => void): void {\n    this._listen('done', fn);\n  }\n\n  onStart(fn: () => void): void {\n    this._listen('start', fn);\n  }\n\n  onDestroy(fn: () => void): void {\n    this._listen('destroy', fn);\n  }\n\n  init(): void {\n    this._command('init');\n  }\n\n  hasStarted(): boolean {\n    return this._started;\n  }\n\n  play(): void {\n    this._command('play');\n    this._started = true;\n  }\n\n  pause(): void {\n    this._command('pause');\n  }\n\n  restart(): void {\n    this._command('restart');\n  }\n\n  finish(): void {\n    this._command('finish');\n  }\n\n  destroy(): void {\n    this._command('destroy');\n  }\n\n  reset(): void {\n    this._command('reset');\n    this._started = false;\n  }\n\n  setPosition(p: number): void {\n    this._command('setPosition', p);\n  }\n\n  getPosition(): number {\n    return unwrapAnimationRenderer(this._renderer)?.engine?.players[this.id]?.getPosition() ?? 0;\n  }\n\n  public totalTime = 0;\n}\n\nfunction issueAnimationCommand(\n  renderer: Renderer2,\n  element: any,\n  id: number,\n  command: string,\n  args: any[],\n): void {\n  renderer.setProperty(element, `@@${id}:${command}`, args);\n}\n\n/**\n * The following 2 methods cannot reference their correct types (AnimationRenderer &\n * DynamicDelegationRenderer) since this would introduce a import cycle.\n */\n\nfunction unwrapAnimationRenderer(\n  renderer: Renderer2,\n): {engine: {players: AnimationPlayer[]}} | null {\n  const type = (renderer as unknown as {ɵtype: AnimationRendererType}).ɵtype;\n  if (type === AnimationRendererType.Regular) {\n    return renderer as any;\n  } else if (type === AnimationRendererType.Delegated) {\n    return (renderer as any).animationRenderer;\n  }\n\n  return null;\n}\n\nfunction isAnimationRenderer(renderer: Renderer2): boolean {\n  const type = (renderer as unknown as {ɵtype: AnimationRendererType}).ɵtype;\n  return type === AnimationRendererType.Regular || type === AnimationRendererType.Delegated;\n}\n"],"names":["id","encapsulation","ViewEncapsulation","None","styles","data","animation","_renderer","rootRenderer","createRenderer","doc","body","typeData","animationModuleType","isAnimationRenderer","RuntimeError","ngDevMode","build","_nextAnimationId","Array","isArray","sequence","entry","BrowserAnimationFactory","ɵfac","i0","ɵɵngDeclareFactory","minVersion","version","ngImport","type","BrowserAnimationBuilder","deps","token","RendererFactory2","DOCUMENT","target","ɵɵFactoryTarget","Injectable","ɵprov","ɵɵngDeclareInjectable","providedIn","decorators","args","ctorParameters","Document","create","element","options","RendererAnimationPlayer","_id","_started","constructor","_command","_listen","eventName","callback","listen","command","issueAnimationCommand","fn","init","hasStarted","play","restart","finish"],"mappings":"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"}