{"version":3,"file":"animations-browser.umd.min.js","sources":["../../../../packages/animations/browser/src/render/transition_animation_engine.ts","../../../../packages/animations/browser/src/render/dom_animation_engine_next.ts","../../../../packages/animations/browser/src/render/noop_animation_engine.ts","../../../../packages/animations/browser/src/render/web_animations/web_animations_player.ts","../../../../packages/animations/browser/src/render/web_animations/web_animations_driver.ts","../../../../packages/animations/browser/src/dsl/animation_timeline_builder.ts","../../../../packages/animations/browser/src/dsl/animation.ts","../../../../packages/animations/browser/src/dsl/style_normalization/animation_style_normalizer.ts","../../../../packages/animations/browser/src/dsl/style_normalization/web_animations_style_normalizer.ts","../../../../packages/animations/browser/src/dsl/animation_transition_factory.ts","../../../../packages/animations/browser/src/dsl/animation_trigger.ts","../../../../packages/animations/browser/src/render/timeline_animation_engine.ts","../../../../packages/animations/browser/src/dsl/animation_ast.ts","../../../../packages/animations/browser/src/dsl/animation_ast_builder.ts","../../../../packages/animations/browser/src/dsl/element_instruction_map.ts","../../../../packages/animations/browser/src/render/animation_driver.ts","../../../../packages/animations/browser/src/dsl/animation_transition_instruction.ts","../../../../packages/animations/browser/src/dsl/animation_timeline_instruction.ts","../../../../packages/animations/browser/src/dsl/animation_dsl_visitor.ts","../../../../packages/animations/browser/src/dsl/animation_transition_expr.ts","../../../../packages/animations/browser/src/render/shared.ts","../../../../packages/animations/browser/src/util.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {AnimationTransitionFactory} from '../dsl/animation_transition_factory';\nimport {AnimationTransitionInstruction} from '../dsl/animation_transition_instruction';\nimport {AnimationTrigger} from '../dsl/animation_trigger';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {ENTER_CLASSNAME, LEAVE_CLASSNAME, LEAVE_SELECTOR, NG_ANIMATING_CLASSNAME, NG_TRIGGER_CLASSNAME, NG_TRIGGER_SELECTOR, eraseStyles, iteratorToArray, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst /** @type {?} */ EMPTY_PLAYER_ARRAY: AnimationPlayer[] = [];\n\ninterface TriggerListener {\n  name: string;\n  phase: string;\n  callback: (event: any) => any;\n}\n\nexport interface QueueInstruction {\n  element: any;\n  triggerName: string;\n  fromState: StateValue;\n  toState: StateValue;\n  transition: AnimationTransitionFactory;\n  player: TransitionAnimationPlayer;\n  isFallbackTransition: boolean;\n}\nexport class StateValue {\npublic value: string;\npublic data: {[key: string]: any};\n/**\n * @param {?} input\n */\nconstructor(input: any) {\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    this.data = isObj ? input : {value: value};\n  }\n/**\n * @param {?} values\n * @return {?}\n */\nabsorbValues(values: {[key: string]: any}) {\n    Object.keys(values).forEach(prop => {\n      if (this.data[prop] == null) {\n        this.data[prop] = values[prop];\n      }\n    });\n  }\n}\n\nfunction StateValue_tsickle_Closure_declarations() {\n/** @type {?} */\nStateValue.prototype.value;\n/** @type {?} */\nStateValue.prototype.data;\n}\n\n\nexport const /** @type {?} */ VOID_VALUE = 'void';\nexport const /** @type {?} */ DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\nexport const /** @type {?} */ DELETED_STATE_VALUE = new StateValue('DELETED');\n\nconst /** @type {?} */ POTENTIAL_ENTER_CLASSNAME = ENTER_CLASSNAME + '-temp';\nconst /** @type {?} */ POTENTIAL_ENTER_SELECTOR = '.' + POTENTIAL_ENTER_CLASSNAME;\nexport class AnimationTransitionNamespace {\npublic players: TransitionAnimationPlayer[] = [];\nprivate _triggers: {[triggerName: string]: AnimationTrigger} = {};\nprivate _queue: QueueInstruction[] = [];\nprivate _elementListeners = new Map<any, TriggerListener[]>();\nprivate _hostClassName: string;\n/**\n * @param {?} id\n * @param {?} hostElement\n * @param {?} _engine\n */\nconstructor(\npublic id: string,\npublic hostElement: any,\nprivate _engine: TransitionAnimationEngine) {\n    this._hostClassName = 'ng-tns-' + id;\n  }\n/**\n * @param {?} element\n * @param {?} name\n * @param {?} phase\n * @param {?} callback\n * @return {?}\n */\nlisten(element: any, name: string, phase: string, callback: (event: any) => boolean): () => any {\n    if (!this._triggers.hasOwnProperty(name)) {\n      throw new Error(\n          `Unable to listen on the animation trigger event \"${phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n    }\n\n    if (phase == null || phase.length == 0) {\n      throw new Error(\n          `Unable to listen on the animation trigger \"${name}\" because the provided event is undefined!`);\n    }\n\n    if (!isTriggerEventValid(phase)) {\n      throw new Error(\n          `The provided animation trigger event \"${phase}\" for the animation trigger \"${name}\" is not supported!`);\n    }\n\n    const /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);\n    const /** @type {?} */ data = {name, phase, callback};\n    listeners.push(data);\n\n    const /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\n    if (!triggersWithStates.hasOwnProperty(name)) {\n      element.classList.add(NG_TRIGGER_CLASSNAME);\n      element.classList.add(NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates[name] = null;\n    }\n\n    return () => {\n      // the event listener is removed AFTER the flush has occurred such\n      // that leave animations callbacks can fire (otherwise if the node\n      // is removed in between then the listeners would be deregistered)\n      this._engine.afterFlush(() => {\n        const /** @type {?} */ index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n\n        if (!this._triggers[name]) {\n          delete triggersWithStates[name];\n        }\n      });\n    };\n  }\n/**\n * @param {?} name\n * @param {?} ast\n * @return {?}\n */\nregister(name: string, ast: AnimationTrigger): boolean {\n    if (this._triggers[name]) {\n      // throw\n      return false;\n    } else {\n      this._triggers[name] = ast;\n      return true;\n    }\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nprivate _getTrigger(name: string) {\n    const /** @type {?} */ trigger = this._triggers[name];\n    if (!trigger) {\n      throw new Error(`The provided animation trigger \"${name}\" has not been registered!`);\n    }\n    return trigger;\n  }\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} value\n * @param {?=} defaultToFallback\n * @return {?}\n */\ntrigger(element: any, triggerName: string, value: any, defaultToFallback = true):\n      TransitionAnimationPlayer {\n    const /** @type {?} */ trigger = this._getTrigger(triggerName);\n    const /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);\n    if (!document.body.contains(element)) {\n      return player;\n    }\n\n    let /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      element.classList.add(NG_TRIGGER_CLASSNAME);\n      element.classList.add(NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = {});\n    }\n\n    let /** @type {?} */ fromState = triggersWithStates[triggerName];\n    const /** @type {?} */ toState = new StateValue(value);\n\n    const /** @type {?} */ isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbValues(fromState.data);\n    }\n\n    triggersWithStates[triggerName] = toState;\n\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    } else if (fromState === DELETED_STATE_VALUE) {\n      return player;\n    }\n\n    const /** @type {?} */ playersOnElement: TransitionAnimationPlayer[] =\n        getOrSetAsInMap(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      // only remove the player if it is queued on the EXACT same trigger/namespace\n      // we only also deal with queued players here because if the animation has\n      // started then we want to keep the player alive until the flush happens\n      // (which is where the previousPlayers are passed into the new palyer)\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n\n    let /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);\n    let /** @type {?} */ isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return null;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n\n    this._engine.totalQueuedPlayers++;\n    this._queue.push(\n        {element, triggerName, transition, fromState, toState, player, isFallbackTransition});\n\n    if (!isFallbackTransition) {\n      element.classList.add(NG_ANIMATING_CLASSNAME);\n    }\n\n    player.onDone(() => {\n      element.classList.remove(NG_ANIMATING_CLASSNAME);\n\n      let /** @type {?} */ index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n\n      const /** @type {?} */ players = this._engine.playersByElement.get(element);\n      if (players) {\n        let /** @type {?} */ index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n\n    this.players.push(player);\n    playersOnElement.push(player);\n\n    return player;\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nderegister(name: string) {\n    delete this._triggers[name];\n\n    this._engine.statesByElement.forEach((stateMap, element) => { delete stateMap[name]; });\n\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(\n          element, listeners.filter(entry => { return entry.name != name; }));\n    });\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nprivate _onElementDestroy(element: any) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n/**\n * @param {?} rootElement\n * @param {?} context\n * @param {?=} animate\n * @return {?}\n */\nprivate _destroyInnerNodes(rootElement: any, context: any, animate: boolean = false) {\n    listToArray(rootElement.querySelectorAll(NG_TRIGGER_SELECTOR)).forEach(elm => {\n      if (animate && elm.classList.contains(this._hostClassName)) {\n        const /** @type {?} */ innerNs = this._engine.namespacesByHostElement.get(elm);\n\n        // special case for a host element with animations on the same element\n        if (innerNs) {\n          innerNs.removeNode(elm, context, true);\n        }\n\n        this.removeNode(elm, context, true);\n      } else {\n        this._onElementDestroy(elm);\n      }\n    });\n  }\n/**\n * @param {?} element\n * @param {?} context\n * @param {?=} doNotRecurse\n * @return {?}\n */\nremoveNode(element: any, context: any, doNotRecurse?: boolean): void {\n    const /** @type {?} */ engine = this._engine;\n\n    element.classList.add(LEAVE_CLASSNAME);\n    engine.afterFlush(() => element.classList.remove(LEAVE_CLASSNAME));\n\n    if (!doNotRecurse && element.childElementCount) {\n      this._destroyInnerNodes(element, context, true);\n    }\n\n    const /** @type {?} */ triggerStates = engine.statesByElement.get(element);\n    if (triggerStates) {\n      const /** @type {?} */ players: TransitionAnimationPlayer[] = [];\n      Object.keys(triggerStates).forEach(triggerName => {\n        // this check is here in the event that an element is removed\n        // twice (both on the host level and the component level)\n        if (this._triggers[triggerName]) {\n          const /** @type {?} */ player = this.trigger(element, triggerName, VOID_VALUE, false);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => {\n          engine.destroyInnerAnimations(element);\n          this._onElementDestroy(element);\n          engine.onRemovalComplete(element, context);\n        });\n\n        return;\n      }\n    }\n\n    // find the player that is animating and make sure that the\n    // removal is delayed until that player has completed\n    let /** @type {?} */ containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const /** @type {?} */ currentPlayers =\n          engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n\n      // when this `if statement` does not continue forward it means that\n      // a previous animation query has selected the current element and\n      // is animating it. In this situation want to continue fowards and\n      // allow the element to be queued up for animation later.\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let /** @type {?} */ parent = element;\n        while (parent = parent.parentNode) {\n          const /** @type {?} */ triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // at this stage we know that the element will either get removed\n    // during flush or will be picked up by a parent query. Either way\n    // we need to fire the listeners for this element when it DOES get\n    // removed (once the query parent animation is done or after flush)\n    const /** @type {?} */ listeners = this._elementListeners.get(element);\n    if (listeners) {\n      const /** @type {?} */ visitedTriggers = new Set<string>();\n      listeners.forEach(listener => {\n        const /** @type {?} */ triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n\n        const /** @type {?} */ trigger = this._triggers[triggerName];\n        const /** @type {?} */ transition = trigger.fallbackTransition;\n        const /** @type {?} */ fromState = engine.statesByElement.get(element)[triggerName] || DEFAULT_STATE_VALUE;\n        const /** @type {?} */ toState = new StateValue(VOID_VALUE);\n        const /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n\n    // whether or not a parent has an animation we need to delay the deferral of the leave\n    // operation until we have more information (which we do after flush() has been called)\n    if (containsPotentialParentTransition) {\n      engine.queuedRemovals.set(element, () => {\n        engine.destroyInnerAnimations(element);\n        this._onElementDestroy(element);\n        engine.onRemovalComplete(element, context);\n      });\n    } else {\n      // we do this after the flush has occurred such\n      // that the callbacks can be fired\n      engine.afterFlush(() => this._onElementDestroy(element));\n      engine.destroyInnerAnimations(element);\n      engine.onRemovalComplete(element, context);\n    }\n  }\n/**\n * @param {?} element\n * @param {?} parent\n * @return {?}\n */\ninsertNode(element: any, parent: any): void { element.classList.add(this._hostClassName); }\n/**\n * @return {?}\n */\ndrainQueuedTransitions(): QueueInstruction[] {\n    const /** @type {?} */ instructions: QueueInstruction[] = [];\n    this._queue.forEach(entry => {\n      const /** @type {?} */ player = entry.player;\n      if (player.destroyed) return;\n\n      const /** @type {?} */ element = entry.element;\n      const /** @type {?} */ listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach((listener: TriggerListener) => {\n          if (listener.name == entry.triggerName) {\n            const /** @type {?} */ baseEvent = makeAnimationEvent(\n                element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          // now we can destroy the element properly since the event listeners have\n          // been bound to the player\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n\n    this._queue = [];\n\n    return instructions.sort((a, b) => {\n      // if depCount == 0 them move to front\n      // otherwise if a.contains(b) then move back\n      const /** @type {?} */ d0 = a.transition.ast.depCount;\n      const /** @type {?} */ d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return a.element.contains(b.element) ? 1 : -1;\n    });\n  }\n/**\n * @param {?} context\n * @return {?}\n */\ndestroy(context: any) {\n    this.players.forEach(p => p.destroy());\n    this._destroyInnerNodes(this.hostElement, context);\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nelementContainsData(element: any): boolean {\n    let /** @type {?} */ containsData = false;\n    if (this._elementListeners.has(element)) containsData = true;\n    containsData =\n        (this._queue.find(entry => entry.element === element) ? true : false) || containsData;\n    return containsData;\n  }\n}\n\nfunction AnimationTransitionNamespace_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTransitionNamespace.prototype.players;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._triggers;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._queue;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._elementListeners;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._hostClassName;\n/** @type {?} */\nAnimationTransitionNamespace.prototype.id;\n/** @type {?} */\nAnimationTransitionNamespace.prototype.hostElement;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._engine;\n}\n\n\nexport interface QueuedTransition {\n  element: any;\n  instruction: AnimationTransitionInstruction;\n  player: TransitionAnimationPlayer;\n}\nexport class TransitionAnimationEngine {\npublic players: TransitionAnimationPlayer[] = [];\npublic queuedRemovals = new Map<any, () => any>();\npublic newlyInserted = new Set<any>();\npublic newHostElements = new Map<any, AnimationTransitionNamespace>();\npublic playersByElement = new Map<any, TransitionAnimationPlayer[]>();\npublic playersByQueriedElement = new Map<any, TransitionAnimationPlayer[]>();\npublic statesByElement = new Map<any, {[triggerName: string]: StateValue}>();\npublic totalAnimations = 0;\npublic totalQueuedPlayers = 0;\nprivate _namespaceLookup: {[id: string]: AnimationTransitionNamespace} = {};\nprivate _namespaceList: AnimationTransitionNamespace[] = [];\nprivate _flushFns: (() => any)[] = [];\nprivate _whenQuietFns: (() => any)[] = [];\npublic namespacesByHostElement = new Map<any, AnimationTransitionNamespace>();\npublic onRemovalComplete = (element: any, context: any) => {};\n/**\n * @param {?} _driver\n * @param {?} _normalizer\n */\nconstructor(private _driver: AnimationDriver,\nprivate _normalizer: AnimationStyleNormalizer) {}\n/**\n * @return {?}\n */\nget queuedPlayers(): TransitionAnimationPlayer[] {\n    const /** @type {?} */ players: TransitionAnimationPlayer[] = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} hostElement\n * @return {?}\n */\ncreateNamespace(namespaceId: string, hostElement: any) {\n    const /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (hostElement.parentNode) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      // defer this later until flush during when the host element has\n      // been inserted so that we know exactly where to place it in\n      // the namespace list\n      this.newHostElements.set(hostElement, ns);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n/**\n * @param {?} ns\n * @param {?} hostElement\n * @return {?}\n */\nprivate _balanceNamespaceList(ns: AnimationTransitionNamespace, hostElement: any) {\n    const /** @type {?} */ limit = this._namespaceList.length - 1;\n    if (limit >= 0) {\n      let /** @type {?} */ found = false;\n      for (let /** @type {?} */ i = limit; i >= 0; i--) {\n        const /** @type {?} */ nextNamespace = this._namespaceList[i];\n        if (nextNamespace.hostElement.contains(hostElement)) {\n          this._namespaceList.splice(i + 1, 0, ns);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        this._namespaceList.splice(0, 0, ns);\n      }\n    } else {\n      this._namespaceList.push(ns);\n    }\n\n    this.namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} hostElement\n * @param {?} name\n * @param {?} trigger\n * @return {?}\n */\nregister(namespaceId: string, hostElement: any, name: string, trigger: AnimationTrigger) {\n    let /** @type {?} */ ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    if (ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n/**\n * @param {?} namespaceId\n * @param {?} context\n * @return {?}\n */\ndestroy(namespaceId: string, context: any) {\n    const /** @type {?} */ ns = this._fetchNamespace(namespaceId);\n\n    this.afterFlush(() => {\n      this.namespacesByHostElement.delete(ns.hostElement);\n      delete this._namespaceLookup[namespaceId];\n      const /** @type {?} */ index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n    });\n\n    this.afterFlushAnimationsDone(() => ns.destroy(context));\n  }\n/**\n * @param {?} id\n * @return {?}\n */\nprivate _fetchNamespace(id: string) {\n    const /** @type {?} */ ns = this._namespaceLookup[id];\n    if (!ns) {\n      // TODO throw\n    }\n    return ns;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\ntrigger(namespaceId: string, element: any, name: string, value: any): boolean {\n    if (isElementNode(element)) {\n      this._fetchNamespace(namespaceId).trigger(element, name, value);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} parent\n * @param {?} insertBefore\n * @return {?}\n */\ninsertNode(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    if (!isElementNode(element)) return;\n\n    this._fetchNamespace(namespaceId).insertNode(element, parent);\n\n    // only *directives and host elements are inserted before\n    if (insertBefore) {\n      this.newlyInserted.add(element);\n    }\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} context\n * @param {?=} doNotRecurse\n * @return {?}\n */\nremoveNode(namespaceId: string, element: any, context: any, doNotRecurse?: boolean): void {\n    if (!isElementNode(element)) {\n      this.onRemovalComplete(element, context);\n      return;\n    }\n\n    this._fetchNamespace(namespaceId).removeNode(element, context, doNotRecurse);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} name\n * @param {?} phase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      namespaceId: string, element: any, name: string, phase: string,\n      callback: (event: any) => boolean): () => any {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n/**\n * @param {?} entry\n * @param {?} subTimelines\n * @return {?}\n */\nprivate _buildInstruction(entry: QueueInstruction, subTimelines: ElementInstructionMap) {\n    return entry.transition.build(\n        entry.element, entry.fromState.value, entry.toState.value, entry.toState.data,\n        subTimelines);\n  }\n/**\n * @param {?} containerElement\n * @return {?}\n */\ndestroyInnerAnimations(containerElement: any) {\n    listToArray(containerElement.querySelectorAll(NG_TRIGGER_SELECTOR)).forEach(element => {\n      const /** @type {?} */ players = this.playersByElement.get(element);\n      if (players) {\n        players.forEach(player => {\n          // special case for when an element is set for destruction, but hasn't started.\n          // in this situation we want to delay the destruction until the flush occurs\n          // so that any event listeners attached to the player are triggered.\n          if (player.queued) {\n            player.markedForDestroy = true;\n          } else {\n            player.destroy();\n          }\n        });\n      }\n      const /** @type {?} */ stateMap = this.statesByElement.get(element);\n      if (stateMap) {\n        Object.keys(stateMap).forEach(triggerName => stateMap[triggerName] = DELETED_STATE_VALUE);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nflush() {\n    let /** @type {?} */ players: AnimationPlayer[] = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => { this._balanceNamespaceList(ns, element); });\n      this.newHostElements.clear();\n    }\n\n    if (this._namespaceList.length && (this.totalQueuedPlayers || this.queuedRemovals.size)) {\n      players = this._flushAnimations();\n    }\n\n    this.totalQueuedPlayers = 0;\n    this.queuedRemovals.clear();\n    this.newlyInserted.clear();\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n\n    if (this._whenQuietFns.length) {\n      // we move these over to a variable so that\n      // if any new callbacks are registered in another\n      // flush they do not populate the existing set\n      const /** @type {?} */ quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => { quietFns.forEach(fn => fn()); });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n/**\n * @return {?}\n */\nprivate _populateEnterElements() {\n    const /** @type {?} */ allEnterNodes = iteratorToArray(this.newlyInserted.values());\n    allEnterNodes.forEach(element => element.classList.add(POTENTIAL_ENTER_CLASSNAME));\n    const /** @type {?} */ enterNodes = filterNodeClasses(document.body, POTENTIAL_ENTER_SELECTOR);\n    enterNodes.forEach(element => element.classList.add(ENTER_CLASSNAME));\n    allEnterNodes.forEach(element => element.classList.remove(POTENTIAL_ENTER_CLASSNAME));\n    return enterNodes;\n  }\n/**\n * @return {?}\n */\nprivate _flushAnimations(): TransitionAnimationPlayer[] {\n    const /** @type {?} */ subTimelines = new ElementInstructionMap();\n    const /** @type {?} */ skippedPlayers: TransitionAnimationPlayer[] = [];\n    const /** @type {?} */ skippedPlayersMap = new Map<any, AnimationPlayer[]>();\n    const /** @type {?} */ queuedInstructions: QueuedTransition[] = [];\n    const /** @type {?} */ queriedElements = new Map<any, TransitionAnimationPlayer[]>();\n    const /** @type {?} */ allPreStyleElements = new Map<any, Set<string>>();\n    const /** @type {?} */ allPostStyleElements = new Map<any, Set<string>>();\n\n    // this must occur before the instructions are built below such that\n    // the :enter queries match the elements\n    const /** @type {?} */ enterNodes: any[] = this._populateEnterElements();\n\n    for (let /** @type {?} */ i = this._namespaceList.length - 1; i >= 0; i--) {\n      const /** @type {?} */ ns = this._namespaceList[i];\n      ns.drainQueuedTransitions().forEach(entry => {\n        const /** @type {?} */ instruction = this._buildInstruction(entry, subTimelines);\n        const /** @type {?} */ player = entry.player;\n        const /** @type {?} */ element = entry.element;\n\n        // if a unmatched transition is queued to go then it SHOULD NOT render\n        // an animation and cancel the previously running animations.\n        if (entry.isFallbackTransition && !instruction.isRemovalTransition) {\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this means that if a parent animation uses this animation as a sub trigger\n        // then it will instruct the timeline builder to not add a player delay, but\n        // instead stretch the first keyframe gap up until the animation starts. The\n        // reason this is important is to prevent extra initialization styles from being\n        // required by the user in the animation.\n        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);\n\n        subTimelines.append(element, instruction.timelines);\n\n        const /** @type {?} */ tuple = {instruction, player, element};\n\n        queuedInstructions.push(tuple);\n\n        instruction.queriedElements.forEach(\n            element => getOrSetAsInMap(queriedElements, element, []).push(player));\n\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          const /** @type {?} */ props = Object.keys(stringMap);\n          if (props.length) {\n            let /** @type {?} */ setVal = allPreStyleElements.get(element);\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set<string>());\n            }\n            props.forEach(prop => setVal.add(prop));\n          }\n        });\n\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          const /** @type {?} */ props = Object.keys(stringMap);\n          let /** @type {?} */ setVal = allPostStyleElements.get(element);\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set<string>());\n          }\n          props.forEach(prop => setVal.add(prop));\n        });\n      });\n    }\n\n    const /** @type {?} */ allPreviousPlayersMap = new Map<any, TransitionAnimationPlayer[]>();\n    let /** @type {?} */ sortedParentElements: any[] = [];\n    queuedInstructions.forEach(entry => {\n      const /** @type {?} */ element = entry.element;\n      if (subTimelines.has(element)) {\n        sortedParentElements.unshift(element);\n        this._beforeAnimationBuild(\n            entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n\n    allPreviousPlayersMap.forEach(players => { players.forEach(player => player.destroy()); });\n\n    const /** @type {?} */ leaveNodes: any[] = allPostStyleElements.size ?\n        listToArray(document.body.querySelectorAll(LEAVE_SELECTOR)) :\n        [];\n\n    // PRE STAGE: fill the ! styles\n    const /** @type {?} */ preStylesMap = allPreStyleElements.size ?\n        cloakAndComputeStyles(this._driver, enterNodes, allPreStyleElements, PRE_STYLE) :\n        new Map<any, ɵStyleData>();\n\n    // POST STAGE: fill the * styles\n    const /** @type {?} */ postStylesMap =\n        cloakAndComputeStyles(this._driver, leaveNodes, allPostStyleElements, AUTO_STYLE);\n\n    const /** @type {?} */ rootPlayers: TransitionAnimationPlayer[] = [];\n    const /** @type {?} */ subPlayers: TransitionAnimationPlayer[] = [];\n    queuedInstructions.forEach(entry => {\n      const {element, player, instruction} = entry;\n      // this means that it was never consumed by a parent animation which\n      // means that it is independent and therefore should be set for animation\n      if (subTimelines.has(element)) {\n        const /** @type {?} */ innerPlayer = this._buildAnimation(\n            player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap,\n            postStylesMap);\n        player.setRealPlayer(innerPlayer);\n\n        let /** @type {?} */ parentHasPriority: any = null;\n        for (let /** @type {?} */ i = 0; i < sortedParentElements.length; i++) {\n          const /** @type {?} */ parent = sortedParentElements[i];\n          if (parent === element) break;\n          if (parent.contains(element)) {\n            parentHasPriority = parent;\n            break;\n          }\n        }\n\n        if (parentHasPriority) {\n          const /** @type {?} */ parentPlayers = this.playersByElement.get(parentHasPriority);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        } else {\n          rootPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        subPlayers.push(player);\n      }\n    });\n\n    subPlayers.forEach(player => {\n      const /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n\n        const /** @type {?} */ index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n\n    // the reason why we don't actually play the animation is\n    // because all that a skipped player is designed to do is to\n    // fire the start/done transition callback events\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.parentPlayer.onDestroy(() => player.destroy());\n      } else {\n        player.destroy();\n      }\n    });\n\n    // run through all of the queued removals and see if they\n    // were picked up by a query. If not then perform the removal\n    // operation right away unless a parent animation is ongoing.\n    this.queuedRemovals.forEach((fn, element) => {\n      const /** @type {?} */ players = queriedElements.get(element);\n      if (players) {\n        optimizeGroupPlayer(players).onDone(fn);\n      } else {\n        let /** @type {?} */ elementPlayers: AnimationPlayer[] = null;\n\n        let /** @type {?} */ parent = element;\n        while (parent = parent.parentNode) {\n          const /** @type {?} */ playersForThisElement = this.playersByElement.get(parent);\n          if (playersForThisElement && playersForThisElement.length) {\n            elementPlayers = playersForThisElement;\n            break;\n          }\n        }\n\n        if (elementPlayers) {\n          optimizeGroupPlayer(elementPlayers).onDone(fn);\n        } else {\n          fn();\n        }\n      }\n    });\n\n    enterNodes.forEach(element => element.classList.remove(ENTER_CLASSNAME));\n\n    return rootPlayers;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @return {?}\n */\nelementContainsData(namespaceId: string, element: any) {\n    let /** @type {?} */ containsData = false;\n    if (this.queuedRemovals.has(element)) containsData = true;\n    if (this.newlyInserted.has(element)) containsData = true;\n    if (this.playersByElement.has(element)) containsData = true;\n    if (this.playersByQueriedElement.has(element)) containsData = true;\n    if (this.statesByElement.has(element)) containsData = true;\n    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n  }\n/**\n * @param {?} callback\n * @return {?}\n */\nafterFlush(callback: () => any) { this._flushFns.push(callback); }\n/**\n * @param {?} callback\n * @return {?}\n */\nafterFlushAnimationsDone(callback: () => any) { this._whenQuietFns.push(callback); }\n/**\n * @param {?} element\n * @param {?} instruction\n * @param {?} isQueriedElement\n * @param {?=} namespaceId\n * @param {?=} triggerName\n * @return {?}\n */\nprivate _getPreviousPlayers(\n      element: string, instruction: AnimationTransitionInstruction, isQueriedElement: boolean,\n      namespaceId?: string, triggerName?: string): TransitionAnimationPlayer[] {\n    let /** @type {?} */ players: TransitionAnimationPlayer[] = [];\n    if (isQueriedElement) {\n      const /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const /** @type {?} */ elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const /** @type {?} */ isRemovalAnimation = instruction.toState == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != instruction.triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      })\n    }\n    return players;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} instruction\n * @param {?} allPreviousPlayersMap\n * @return {?}\n */\nprivate _beforeAnimationBuild(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>) {\n    // it's important to do this step before destroying the players\n    // so that the onDone callback below won't fire before this\n    eraseStyles(instruction.element, instruction.fromStyles);\n\n    const /** @type {?} */ triggerName = instruction.triggerName;\n    const /** @type {?} */ rootElement = instruction.element;\n\n    // when a removal animation occurs, ALL previous players are collected\n    // and destroyed (even if they are outside of the current namespace)\n    const /** @type {?} */ targetNameSpaceId: string = instruction.isRemovalTransition ? undefined : namespaceId;\n    const /** @type {?} */ targetTriggerName: string = instruction.isRemovalTransition ? undefined : triggerName;\n\n    instruction.timelines.map(timelineInstruction => {\n      const /** @type {?} */ element = timelineInstruction.element;\n      const /** @type {?} */ isQueriedElement = element !== rootElement;\n      const /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\n      const /** @type {?} */ previousPlayers = this._getPreviousPlayers(\n          element, instruction, isQueriedElement, targetNameSpaceId, targetTriggerName);\n      previousPlayers.forEach(player => {\n        const /** @type {?} */ realPlayer = /** @type {?} */(( player.getRealPlayer() as any));\n        if (realPlayer['beforeDestroy']) {\n          realPlayer['beforeDestroy']();\n        }\n        players.push(player);\n      });\n    });\n  }\n/**\n * @param {?} namespaceId\n * @param {?} instruction\n * @param {?} allPreviousPlayersMap\n * @param {?} skippedPlayersMap\n * @param {?} preStylesMap\n * @param {?} postStylesMap\n * @return {?}\n */\nprivate _buildAnimation(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>,\n      skippedPlayersMap: Map<any, AnimationPlayer[]>, preStylesMap: Map<any, ɵStyleData>,\n      postStylesMap: Map<any, ɵStyleData>): AnimationPlayer {\n    const /** @type {?} */ triggerName = instruction.triggerName;\n    const /** @type {?} */ rootElement = instruction.element;\n\n    // we first run this so that the previous animation player\n    // data can be passed into the successive animation players\n    const /** @type {?} */ allQueriedPlayers: TransitionAnimationPlayer[] = [];\n    const /** @type {?} */ allConsumedElements = new Set<any>();\n    const /** @type {?} */ allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const /** @type {?} */ element = timelineInstruction.element;\n\n      // FIXME (matsko): make sure to-be-removed animations are removed properly\n      if (element['REMOVED']) return new NoopAnimationPlayer();\n\n      const /** @type {?} */ isQueriedElement = element !== rootElement;\n      let /** @type {?} */ previousPlayers: AnimationPlayer[] = EMPTY_PLAYER_ARRAY;\n      if (!allConsumedElements.has(element)) {\n        allConsumedElements.add(element);\n        const /** @type {?} */ _previousPlayers = allPreviousPlayersMap.get(element);\n        if (_previousPlayers) {\n          previousPlayers = _previousPlayers.map(p => p.getRealPlayer());\n        }\n      }\n      const /** @type {?} */ preStyles = preStylesMap.get(element);\n      const /** @type {?} */ postStyles = postStylesMap.get(element);\n      const /** @type {?} */ keyframes = normalizeKeyframes(\n          this._driver, this._normalizer, element, timelineInstruction.keyframes, preStyles,\n          postStyles);\n      const /** @type {?} */ player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n\n      // this means that this particular player belongs to a sub trigger. It is\n      // important that we match this player up with the corresponding (@trigger.listener)\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        getOrSetAsInMap(skippedPlayersMap, element, []).push(player);\n      }\n\n      if (isQueriedElement) {\n        const /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n\n      return player;\n    });\n\n    allQueriedPlayers.forEach(player => {\n      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(\n          () => { deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player); });\n    });\n\n    allConsumedElements.forEach(element => { element.classList.add(NG_ANIMATING_CLASSNAME); });\n\n    const /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);\n    player.onDone(() => {\n      allConsumedElements.forEach(element => { element.classList.remove(NG_ANIMATING_CLASSNAME); });\n      setStyles(rootElement, instruction.toStyles);\n    });\n    return player;\n  }\n/**\n * @param {?} instruction\n * @param {?} keyframes\n * @param {?} previousPlayers\n * @return {?}\n */\nprivate _buildPlayer(\n      instruction: AnimationTimelineInstruction, keyframes: ɵStyleData[],\n      previousPlayers: AnimationPlayer[]): AnimationPlayer {\n    if (keyframes.length > 0) {\n      return this._driver.animate(\n          instruction.element, keyframes, instruction.duration, instruction.delay,\n          instruction.easing, previousPlayers);\n    }\n\n    // special case for when an empty transition|definition is provided\n    // ... there is no point in rendering an empty animation\n    return new NoopAnimationPlayer();\n  }\n}\n\nfunction TransitionAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nTransitionAnimationEngine.prototype.players;\n/** @type {?} */\nTransitionAnimationEngine.prototype.queuedRemovals;\n/** @type {?} */\nTransitionAnimationEngine.prototype.newlyInserted;\n/** @type {?} */\nTransitionAnimationEngine.prototype.newHostElements;\n/** @type {?} */\nTransitionAnimationEngine.prototype.playersByElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.playersByQueriedElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.statesByElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.totalAnimations;\n/** @type {?} */\nTransitionAnimationEngine.prototype.totalQueuedPlayers;\n/** @type {?} */\nTransitionAnimationEngine.prototype._namespaceLookup;\n/** @type {?} */\nTransitionAnimationEngine.prototype._namespaceList;\n/** @type {?} */\nTransitionAnimationEngine.prototype._flushFns;\n/** @type {?} */\nTransitionAnimationEngine.prototype._whenQuietFns;\n/** @type {?} */\nTransitionAnimationEngine.prototype.namespacesByHostElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.onRemovalComplete;\n/** @type {?} */\nTransitionAnimationEngine.prototype._driver;\n/** @type {?} */\nTransitionAnimationEngine.prototype._normalizer;\n}\n\nexport class TransitionAnimationPlayer implements AnimationPlayer {\nprivate _player: AnimationPlayer = new NoopAnimationPlayer();\nprivate _containsRealPlayer = false;\nprivate _queuedCallbacks: {[name: string]: (() => any)[]} = {};\nprivate _destroyed = false;\npublic parentPlayer: AnimationPlayer;\npublic markedForDestroy: boolean = false;\n/**\n * @param {?} namespaceId\n * @param {?} triggerName\n * @param {?} element\n */\nconstructor(public namespaceId: string,\npublic triggerName: string,\npublic element: any) {}\n/**\n * @return {?}\n */\nget queued() { return this._containsRealPlayer == false; }\n/**\n * @return {?}\n */\nget destroyed() { return this._destroyed; }\n/**\n * @param {?} player\n * @return {?}\n */\nsetRealPlayer(player: AnimationPlayer) {\n    if (this._containsRealPlayer) return;\n\n    this._player = player;\n    Object.keys(this._queuedCallbacks).forEach(phase => {\n      this._queuedCallbacks[phase].forEach(\n          callback => { listenOnPlayer(player, phase, null, callback); });\n    });\n    this._queuedCallbacks = {};\n    this._containsRealPlayer = true;\n  }\n/**\n * @return {?}\n */\ngetRealPlayer() { return this._player; }\n/**\n * @param {?} name\n * @param {?} callback\n * @return {?}\n */\nprivate _queueEvent(name: string, callback: (event: any) => any): void {\n    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n/**\n * @return {?}\n */\ninit(): void { this._player.init(); }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this.queued ? false : this._player.hasStarted(); }\n/**\n * @return {?}\n */\nplay(): void { !this.queued && this._player.play(); }\n/**\n * @return {?}\n */\npause(): void { !this.queued && this._player.pause(); }\n/**\n * @return {?}\n */\nrestart(): void { !this.queued && this._player.restart(); }\n/**\n * @return {?}\n */\nfinish(): void { this._player.finish(); }\n/**\n * @return {?}\n */\ndestroy(): void {\n    this._destroyed = true;\n    this._player.destroy();\n  }\n/**\n * @return {?}\n */\nreset(): void { !this.queued && this._player.reset(); }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: any): void {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n/**\n * @return {?}\n */\ngetPosition(): number { return this.queued ? 0 : this._player.getPosition(); }\n/**\n * @return {?}\n */\nget totalTime(): number { return this._player.totalTime; }\n}\n\nfunction TransitionAnimationPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nTransitionAnimationPlayer.prototype._player;\n/** @type {?} */\nTransitionAnimationPlayer.prototype._containsRealPlayer;\n/** @type {?} */\nTransitionAnimationPlayer.prototype._queuedCallbacks;\n/** @type {?} */\nTransitionAnimationPlayer.prototype._destroyed;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.parentPlayer;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.markedForDestroy;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.namespaceId;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.triggerName;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.element;\n}\n\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} value\n * @return {?}\n */\nfunction deleteOrUnsetInMap(map: Map<any, any[]>| {[key: string]: any}, key: any, value: any) {\n  let /** @type {?} */ currentValues: any[];\n  if (map instanceof Map) {\n    currentValues = map.get(key);\n    if (currentValues) {\n      if (currentValues.length) {\n        const /** @type {?} */ index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        map.delete(key);\n      }\n    }\n  } else {\n    currentValues = map[key];\n    if (currentValues) {\n      if (currentValues.length) {\n        const /** @type {?} */ index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        delete map[key];\n      }\n    }\n  }\n  return currentValues;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction normalizeTriggerValue(value: any): string {\n  switch (typeof value) {\n    case 'boolean':\n      return value ? '1' : '0';\n    default:\n      return value ? value.toString() : null;\n  }\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction isElementNode(node: any) {\n  return node && node['nodeType'] === 1;\n}\n/**\n * @param {?} eventName\n * @return {?}\n */\nfunction isTriggerEventValid(eventName: string): boolean {\n  return eventName == 'start' || eventName == 'done';\n}\n/**\n * @param {?} element\n * @param {?=} value\n * @return {?}\n */\nfunction cloakElement(element: any, value?: string) {\n  const /** @type {?} */ oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\n/**\n * @param {?} rootElement\n * @param {?} selector\n * @return {?}\n */\nfunction filterNodeClasses(rootElement: any, selector: string): any[] {\n  const /** @type {?} */ rootElements: any[] = [];\n  let /** @type {?} */ cursor: any = rootElement;\n  let /** @type {?} */ nextCursor = null;\n  do {\n    nextCursor = cursor.querySelector(selector);\n    if (!nextCursor) {\n      cursor = cursor.parentElement;\n      if (!cursor) break;\n      nextCursor = cursor = cursor.nextElementSibling;\n    } else {\n      while (nextCursor && nextCursor.matches(selector)) {\n        rootElements.push(nextCursor);\n        nextCursor = nextCursor.nextElementSibling;\n        if (nextCursor) {\n          cursor = nextCursor;\n        } else {\n          cursor = cursor.parentElement;\n          if (!cursor) break;\n          nextCursor = cursor = cursor.nextElementSibling;\n        }\n      }\n    }\n  } while (nextCursor && nextCursor !== rootElement);\n\n  return rootElements;\n}\n/**\n * @param {?} driver\n * @param {?} elements\n * @param {?} elementPropsMap\n * @param {?} defaultStyle\n * @return {?}\n */\nfunction cloakAndComputeStyles(\n    driver: AnimationDriver, elements: any[], elementPropsMap: Map<any, Set<string>>,\n    defaultStyle: string): Map<any, ɵStyleData> {\n  const /** @type {?} */ cloakVals = elements.map(element => cloakElement(element));\n  const /** @type {?} */ valuesMap = new Map<any, ɵStyleData>();\n\n  elementPropsMap.forEach((props: Set<string>, element: any) => {\n    const /** @type {?} */ styles: ɵStyleData = {};\n    props.forEach(prop => {\n      const /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\n      if (value == '' && value.length == 0) {\n        element['REMOVED'] = true;\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n\n  elements.forEach((element, i) => cloakElement(element, cloakVals[i]));\n  return valuesMap;\n}\n/**\n * @param {?} list\n * @return {?}\n */\nfunction listToArray(list: any): any[] {\n  const /** @type {?} */ arr: any[] = [];\n  arr.push(...( /** @type {?} */((list as any[]))));\n  return arr;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, AnimationPlayer, AnimationTriggerMetadata} from '@angular/animations';\n\nimport {AnimationEngine} from '../animation_engine';\nimport {AnimationTriggerAst} from '../dsl/animation_ast';\nimport {buildAnimationAst} from '../dsl/animation_ast_builder';\nimport {AnimationTrigger, buildTrigger} from '../dsl/animation_trigger';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\n\nimport {AnimationDriver} from './animation_driver';\nimport {TimelineAnimationEngine} from './timeline_animation_engine';\nimport {TransitionAnimationEngine} from './transition_animation_engine';\nexport class DomAnimationEngine implements AnimationEngine {\nprivate _transitionEngine: TransitionAnimationEngine;\nprivate _timelineEngine: TimelineAnimationEngine;\nprivate _triggerCache: {[key: string]: AnimationTrigger} = {};\npublic onRemovalComplete = (element: any, context: any) => {};\n/**\n * @param {?} driver\n * @param {?} normalizer\n */\nconstructor(driver: AnimationDriver, normalizer: AnimationStyleNormalizer) {\n    this._transitionEngine = new TransitionAnimationEngine(driver, normalizer);\n    this._timelineEngine = new TimelineAnimationEngine(driver, normalizer);\n\n    this._transitionEngine.onRemovalComplete =\n        (element: any, context: any) => { this.onRemovalComplete(element, context); }\n  }\n/**\n * @param {?} componentId\n * @param {?} namespaceId\n * @param {?} hostElement\n * @param {?} name\n * @param {?} metadata\n * @return {?}\n */\nregisterTrigger(\n      componentId: string, namespaceId: string, hostElement: any, name: string,\n      metadata: AnimationTriggerMetadata): void {\n    const /** @type {?} */ cacheKey = componentId + '-' + name;\n    let /** @type {?} */ trigger = this._triggerCache[cacheKey];\n    if (!trigger) {\n      const /** @type {?} */ errors: any[] = [];\n      const /** @type {?} */ ast = /** @type {?} */(( buildAnimationAst( /** @type {?} */((metadata as AnimationMetadata)), errors) as AnimationTriggerAst));\n      if (errors.length) {\n        throw new Error(\n            `The animation trigger \"${name}\" has failed to build due to the following errors:\\n - ${errors.join(\"\\n - \")}`);\n      }\n      trigger = buildTrigger(name, ast);\n      this._triggerCache[cacheKey] = trigger;\n    }\n\n    this._transitionEngine.register(namespaceId, hostElement, name, trigger);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} context\n * @return {?}\n */\ndestroy(namespaceId: string, context: any) {\n    this._transitionEngine.destroy(namespaceId, context);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} parent\n * @param {?} insertBefore\n * @return {?}\n */\nonInsert(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nonRemove(namespaceId: string, element: any, context: any): void {\n    this._transitionEngine.removeNode(namespaceId, element, context);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(namespaceId: string, element: any, property: string, value: any): boolean {\n    // @@property\n    if (property.charAt(0) == '@') {\n      const [id, action] = parseCustomCommand(property);\n      const /** @type {?} */ args = /** @type {?} */(( value as any[]));\n      this._timelineEngine.command(id, element, action, args);\n      return false;\n    }\n    return this._transitionEngine.trigger(namespaceId, element, property, value);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      namespaceId: string, element: any, eventName: string, eventPhase: string,\n      callback: (event: any) => any): () => any {\n    // @@listen\n    if (eventName.charAt(0) == '@') {\n      const [id, action] = parseCustomCommand(eventName);\n      return this._timelineEngine.listen(id, element, action, callback);\n    }\n    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\n  }\n/**\n * @return {?}\n */\nflush(): void { this._transitionEngine.flush(); }\n/**\n * @return {?}\n */\nget players(): AnimationPlayer[] {\n    return ( /** @type {?} */((this._transitionEngine.players as AnimationPlayer[])))\n        .concat( /** @type {?} */((this._timelineEngine.players as AnimationPlayer[])));\n  }\n}\n\nfunction DomAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nDomAnimationEngine.prototype._transitionEngine;\n/** @type {?} */\nDomAnimationEngine.prototype._timelineEngine;\n/** @type {?} */\nDomAnimationEngine.prototype._triggerCache;\n/** @type {?} */\nDomAnimationEngine.prototype.onRemovalComplete;\n}\n\n/**\n * @param {?} command\n * @return {?}\n */\nfunction parseCustomCommand(command: string): [string, string] {\n  const /** @type {?} */ separatorPos = command.indexOf(':');\n  const /** @type {?} */ id = command.substring(1, separatorPos);\n  const /** @type {?} */ action = command.substr(separatorPos + 1);\n  return [id, action];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationEvent, AnimationMetadataType, AnimationPlayer, AnimationStateMetadata, AnimationTriggerMetadata, ɵStyleData} from '@angular/animations';\n\nimport {AnimationEngine} from '../animation_engine';\nimport {AnimationTriggerAst} from '../dsl/animation_ast';\nimport {buildAnimationAst} from '../dsl/animation_ast_builder';\nimport {buildTrigger} from '../dsl/animation_trigger';\nimport {copyStyles, eraseStyles, normalizeStyles, setStyles} from '../util';\n\ninterface ListenerTuple {\n  eventPhase: string;\n  triggerName: string;\n  namespacedName: string;\n  callback: (event: any) => any;\n  doRemove?: boolean;\n}\n\ninterface ChangeTuple {\n  element: any;\n  namespacedName: string;\n  triggerName: string;\n  oldValue: string;\n  newValue: string;\n}\n\nconst /** @type {?} */ DEFAULT_STATE_VALUE = 'void';\nconst /** @type {?} */ DEFAULT_STATE_STYLES = '*';\nexport class NoopAnimationEngine extends AnimationEngine {\nprivate _listeners = new Map<any, ListenerTuple[]>();\nprivate _changes: ChangeTuple[] = [];\nprivate _flaggedRemovals = new Set<any>();\nprivate _onDoneFns: (() => any)[] = [];\nprivate _triggerStyles: {[triggerName: string]: {[stateName: string]: ɵStyleData}} =\n      Object.create(null);\npublic onRemovalComplete = (element: any, context: any) => {};\n/**\n * @param {?} componentId\n * @param {?} namespaceId\n * @param {?} hostElement\n * @param {?} name\n * @param {?} metadata\n * @return {?}\n */\nregisterTrigger(\n      componentId: string, namespaceId: string, hostElement: any, name: string,\n      metadata: AnimationTriggerMetadata): void {\n    name = name || metadata.name;\n    name = namespaceId + '#' + name;\n    if (this._triggerStyles[name]) {\n      return;\n    }\n\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ ast = /** @type {?} */(( buildAnimationAst(metadata, errors) as AnimationTriggerAst));\n    const /** @type {?} */ trigger = buildTrigger(name, ast);\n    this._triggerStyles[name] = trigger.states;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} parent\n * @param {?} insertBefore\n * @return {?}\n */\nonInsert(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {}\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nonRemove(namespaceId: string, element: any, context: any): void {\n    this.onRemovalComplete(element, context);\n    if (element['nodeType'] == 1) {\n      this._flaggedRemovals.add(element);\n    }\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(namespaceId: string, element: any, property: string, value: any): void {\n    if (property.charAt(0) == '@') return;  // TODO\n\n    const /** @type {?} */ namespacedName = namespaceId + '#' + property;\n    const /** @type {?} */ storageProp = makeStorageProp(namespacedName);\n    const /** @type {?} */ oldValue = element[storageProp] || DEFAULT_STATE_VALUE;\n    this._changes.push( /** @type {?} */((\n        <ChangeTuple>{element, oldValue, newValue: value, triggerName: property, namespacedName})));\n\n    const /** @type {?} */ triggerStateStyles = this._triggerStyles[namespacedName] || {};\n    const /** @type {?} */ fromStateStyles =\n        triggerStateStyles[oldValue] || triggerStateStyles[DEFAULT_STATE_STYLES];\n    if (fromStateStyles) {\n      eraseStyles(element, fromStateStyles);\n    }\n\n    element[storageProp] = value;\n    this._onDoneFns.push(() => {\n      const /** @type {?} */ toStateStyles = triggerStateStyles[value] || triggerStateStyles[DEFAULT_STATE_STYLES];\n      if (toStateStyles) {\n        setStyles(element, toStateStyles);\n      }\n    });\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      namespaceId: string, element: any, eventName: string, eventPhase: string,\n      callback: (event: any) => any): () => any {\n    if (eventName.charAt(0) == '@') return;  // TODO\n\n    let /** @type {?} */ listeners = this._listeners.get(element);\n    if (!listeners) {\n      this._listeners.set(element, listeners = []);\n    }\n\n    const /** @type {?} */ tuple = /** @type {?} */(( <ListenerTuple>{\n      namespacedName: namespaceId + '#' + eventName,\n      triggerName: eventName, eventPhase, callback\n    }));\n    listeners.push(tuple);\n\n    return () => tuple.doRemove = true;\n  }\n/**\n * @return {?}\n */\nflush(): void {\n    const /** @type {?} */ onStartCallbacks: (() => any)[] = [];\n    const /** @type {?} */ onDoneCallbacks: (() => any)[] = [];\n/**\n * @param {?} listener\n * @param {?} data\n * @return {?}\n */\nfunction handleListener(listener: ListenerTuple, data: ChangeTuple) {\n      const /** @type {?} */ phase = listener.eventPhase;\n      const /** @type {?} */ event = makeAnimationEvent(\n          data.element, data.triggerName, data.oldValue, data.newValue, phase, 0);\n      if (phase == 'start') {\n        onStartCallbacks.push(() => listener.callback(event));\n      } else if (phase == 'done') {\n        onDoneCallbacks.push(() => listener.callback(event));\n      }\n    }\n\n    this._changes.forEach(change => {\n      const /** @type {?} */ element = change.element;\n      const /** @type {?} */ listeners = this._listeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          if (listener.namespacedName == change.namespacedName) {\n            handleListener(listener, change);\n          }\n        });\n      }\n    });\n\n    // upon removal ALL the animation triggers need to get fired\n    this._flaggedRemovals.forEach(element => {\n      const /** @type {?} */ listeners = this._listeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          const /** @type {?} */ triggerName = listener.triggerName;\n          const /** @type {?} */ namespacedName = listener.namespacedName;\n          const /** @type {?} */ storageProp = makeStorageProp(namespacedName);\n          handleListener(listener, /** @type {?} */(( <ChangeTuple>{\n            element,\n            triggerName,\n            namespacedName: listener.namespacedName,\n            oldValue: element[storageProp] || DEFAULT_STATE_VALUE,\n            newValue: DEFAULT_STATE_VALUE\n          })));\n        });\n      }\n    });\n\n    // remove all the listeners after everything is complete\n    Array.from(this._listeners.keys()).forEach(element => {\n      const /** @type {?} */ listenersToKeep = this._listeners.get(element).filter(l => !l.doRemove);\n      if (listenersToKeep.length) {\n        this._listeners.set(element, listenersToKeep);\n      } else {\n        this._listeners.delete(element);\n      }\n    });\n\n    onStartCallbacks.forEach(fn => fn());\n    onDoneCallbacks.forEach(fn => fn());\n    this._flaggedRemovals.clear();\n    this._changes = [];\n\n    this._onDoneFns.forEach(doneFn => doneFn());\n    this._onDoneFns = [];\n  }\n/**\n * @return {?}\n */\nget players(): AnimationPlayer[] { return []; }\n/**\n * @param {?} namespaceId\n * @return {?}\n */\ndestroy(namespaceId: string) {}\n}\n\nfunction NoopAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopAnimationEngine.prototype._listeners;\n/** @type {?} */\nNoopAnimationEngine.prototype._changes;\n/** @type {?} */\nNoopAnimationEngine.prototype._flaggedRemovals;\n/** @type {?} */\nNoopAnimationEngine.prototype._onDoneFns;\n/** @type {?} */\nNoopAnimationEngine.prototype._triggerStyles;\n/** @type {?} */\nNoopAnimationEngine.prototype.onRemovalComplete;\n}\n\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} phaseName\n * @param {?} totalTime\n * @return {?}\n */\nfunction makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string,\n    totalTime: number): AnimationEvent {\n  return /** @type {?} */(( <AnimationEvent>{element, triggerName, fromState, toState, phaseName, totalTime}));\n}\n/**\n * @param {?} property\n * @return {?}\n */\nfunction makeStorageProp(property: string): string {\n  return '_@_' + property;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer} from '@angular/animations';\n\nimport {copyStyles, eraseStyles, setStyles} from '../../util';\n\nimport {DOMAnimation} from './dom_animation';\nexport class WebAnimationsPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _onDestroyFns: Function[] = [];\nprivate _player: DOMAnimation;\nprivate _duration: number;\nprivate _delay: number;\nprivate _initialized = false;\nprivate _finished = false;\nprivate _started = false;\nprivate _destroyed = false;\nprivate _finalKeyframe: {[key: string]: string | number};\npublic time = 0;\npublic parentPlayer: AnimationPlayer = null;\npublic previousStyles: {[styleName: string]: string | number};\npublic currentSnapshot: {[styleName: string]: string | number} = {};\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} options\n * @param {?=} previousPlayers\n */\nconstructor(\npublic element: any,\npublic keyframes: {[key: string]: string | number}[],\npublic options: {[key: string]: string | number},\nprivate previousPlayers: WebAnimationsPlayer[] = []) {\n    this._duration = <number>options['duration'];\n    this._delay = <number>options['delay'] || 0;\n    this.time = this._duration + this._delay;\n\n    this.previousStyles = {};\n    previousPlayers.forEach(player => {\n      let styles = player.currentSnapshot;\n      Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n    });\n  }\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @return {?}\n */\ninit(): void {\n    if (this._initialized) return;\n    this._initialized = true;\n\n    const /** @type {?} */ keyframes = this.keyframes.map(styles => copyStyles(styles, false));\n    const /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);\n    if (previousStyleProps.length) {\n      let /** @type {?} */ startingKeyframe = keyframes[0];\n      let /** @type {?} */ missingStyleProps: string[] = [];\n      previousStyleProps.forEach(prop => {\n        if (!startingKeyframe.hasOwnProperty(prop)) {\n          missingStyleProps.push(prop);\n        }\n        startingKeyframe[prop] = this.previousStyles[prop];\n      });\n\n      if (missingStyleProps.length) {\n        const /** @type {?} */ self = this;\n        // tslint:disable-next-line\n        for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {\n          let /** @type {?} */ kf = keyframes[i];\n          missingStyleProps.forEach(function(prop) {\n            kf[prop] = _computeStyle(self.element, prop);\n          });\n        }\n      }\n    }\n\n    this._player = this._triggerWebAnimation(this.element, keyframes, this.options);\n    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};\n\n    // this is required so that the player doesn't start to animate right away\n    if (this._delay) {\n      this._resetDomPlayerState();\n    } else {\n      this._player.pause();\n    }\n    this._player.addEventListener('finish', () => this._onFinish());\n  }\n/**\n * \\@internal\n * @param {?} element\n * @param {?} keyframes\n * @param {?} options\n * @return {?}\n */\n_triggerWebAnimation(element: any, keyframes: any[], options: any): DOMAnimation {\n    // jscompiler doesn't seem to know animate is a native property because it's not fully\n    // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]\n    return /** @type {?} */(( element['animate'](keyframes, options) as DOMAnimation));\n  }\n/**\n * @return {?}\n */\nget domPlayer() { return this._player; }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nplay(): void {\n    this.init();\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n    }\n    this._player.play();\n  }\n/**\n * @return {?}\n */\npause(): void {\n    this.init();\n    this._player.pause();\n  }\n/**\n * @return {?}\n */\nfinish(): void {\n    this.init();\n    this._onFinish();\n    this._player.finish();\n  }\n/**\n * @return {?}\n */\nreset(): void {\n    this._resetDomPlayerState();\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n  }\n/**\n * @return {?}\n */\nprivate _resetDomPlayerState() {\n    if (this._player) {\n      this._player.cancel();\n    }\n  }\n/**\n * @return {?}\n */\nrestart(): void {\n    this.reset();\n    this.play();\n  }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this._started; }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (!this._destroyed) {\n      this._resetDomPlayerState();\n      this._onFinish();\n      this._destroyed = true;\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void { this._player.currentTime = p * this.time; }\n/**\n * @return {?}\n */\ngetPosition(): number { return this._player.currentTime / this.time; }\n/**\n * @return {?}\n */\nget totalTime(): number { return this._delay + this._duration; }\n/**\n * @return {?}\n */\nbeforeDestroy() {\n    const /** @type {?} */ styles: {[key: string]: string | number} = {};\n    if (this.hasStarted()) {\n      Object.keys(this._finalKeyframe).forEach(prop => {\n        if (prop != 'offset') {\n          styles[prop] =\n              this._finished ? this._finalKeyframe[prop] : _computeStyle(this.element, prop);\n        }\n      });\n    }\n    this.currentSnapshot = styles;\n  }\n}\n\nfunction WebAnimationsPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nWebAnimationsPlayer.prototype._onDoneFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._onStartFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._onDestroyFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._player;\n/** @type {?} */\nWebAnimationsPlayer.prototype._duration;\n/** @type {?} */\nWebAnimationsPlayer.prototype._delay;\n/** @type {?} */\nWebAnimationsPlayer.prototype._initialized;\n/** @type {?} */\nWebAnimationsPlayer.prototype._finished;\n/** @type {?} */\nWebAnimationsPlayer.prototype._started;\n/** @type {?} */\nWebAnimationsPlayer.prototype._destroyed;\n/** @type {?} */\nWebAnimationsPlayer.prototype._finalKeyframe;\n/** @type {?} */\nWebAnimationsPlayer.prototype.time;\n/** @type {?} */\nWebAnimationsPlayer.prototype.parentPlayer;\n/** @type {?} */\nWebAnimationsPlayer.prototype.previousStyles;\n/** @type {?} */\nWebAnimationsPlayer.prototype.currentSnapshot;\n/** @type {?} */\nWebAnimationsPlayer.prototype.element;\n/** @type {?} */\nWebAnimationsPlayer.prototype.keyframes;\n/** @type {?} */\nWebAnimationsPlayer.prototype.options;\n/** @type {?} */\nWebAnimationsPlayer.prototype.previousPlayers;\n}\n\n/**\n * @param {?} element\n * @param {?} prop\n * @return {?}\n */\nfunction _computeStyle(element: any, prop: string): string {\n  return ( /** @type {?} */((<any>window.getComputedStyle(element))))[prop];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../animation_driver';\n\nimport {WebAnimationsPlayer} from './web_animations_player';\nexport class WebAnimationsDriver implements AnimationDriver {\n/**\n * @param {?} element\n * @param {?} prop\n * @param {?=} defaultValue\n * @return {?}\n */\ncomputeStyle(element: any, prop: string, defaultValue?: string): string {\n    return /** @type {?} */(( ( /** @type {?} */((window.getComputedStyle(element) as any)))[prop] as string));\n  }\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @param {?=} previousPlayers\n * @return {?}\n */\nanimate(\n      element: any, keyframes: ɵStyleData[], duration: number, delay: number, easing: string,\n      previousPlayers: AnimationPlayer[] = []): WebAnimationsPlayer {\n    const /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';\n    const /** @type {?} */ playerOptions: {[key: string]: string | number} = {duration, delay, fill};\n\n    // we check for this to avoid having a null|undefined value be present\n    // for the easing (which results in an error for certain browsers #9752)\n    if (easing) {\n      playerOptions['easing'] = easing;\n    }\n\n    const /** @type {?} */ previousWebAnimationPlayers = /** @type {?} */(( <WebAnimationsPlayer[]>previousPlayers.filter(\n        player => { return player instanceof WebAnimationsPlayer; })));\n    return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);\n  }\n}\n/**\n * @return {?}\n */\nexport function supportsWebAnimations() {\n  return typeof Element !== 'undefined' && typeof( /** @type {?} */((<any>Element))).prototype['animate'] === 'function';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimateTimings, PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {copyObj, copyStyles, interpolateStyleLocals, iteratorToArray, resolveTimingValue} from '../util';\n\nimport {AnimationAnimateAst, AnimationAnimateChildAst, AnimationAst, AnimationAstVisitor, AnimationGroupAst, AnimationKeyframesSequenceAst, AnimationQueryAst, AnimationReferenceAst, AnimationSequenceAst, AnimationStaggerAst, AnimationStateAst, AnimationStyleAst, AnimationTimingAst, AnimationTransitionAst, AnimationTriggerAst, AnimationWaitAst, DynamicAnimationTimingAst} from './animation_ast';\nimport {AnimationTimelineInstruction, createTimelineInstruction} from './animation_timeline_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\n/**\n * @param {?} rootElement\n * @param {?} ast\n * @param {?=} startingStyles\n * @param {?=} finalStyles\n * @param {?=} locals\n * @param {?=} subInstructions\n * @param {?=} errors\n * @return {?}\n */\nexport function buildAnimationTimelines(\n    rootElement: any, ast: AnimationAst, startingStyles: ɵStyleData = {},\n    finalStyles: ɵStyleData = {}, locals: {[varName: string]: string | number | boolean},\n    subInstructions: ElementInstructionMap, errors: any[]): AnimationTimelineInstruction[] {\n  return new AnimationTimelineBuilderVisitor().buildKeyframes(\n      rootElement, ast, startingStyles, finalStyles, locals, subInstructions, errors);\n}\n\nexport declare type StyleAtTime = {\n  time: number; value: string | number;\n};\n\nconst /** @type {?} */ DEFAULT_NOOP_PREVIOUS_NODE = /** @type {?} */(( <AnimationAst>{}));\nexport class AnimationTimelineContext {\n  parentContext: AnimationTimelineContext = null;\n  currentTimeline: TimelineBuilder;\n  currentAnimateTimings: AnimateTimings;\n  previousNode: AnimationAst = DEFAULT_NOOP_PREVIOUS_NODE;\n  subContextCount = 0;\n  locals: {[varName: string]: string | number | boolean} = null;\n  subInstructions: ElementInstructionMap;\n  currentQueryIndex: number = 0;\n  currentQueryTotal: number = 0;\n  currentStaggerTime: number = 0;\n/**\n * @param {?} element\n * @param {?} subInstructions\n * @param {?} errors\n * @param {?} timelines\n * @param {?=} initialTimeline\n */\nconstructor(\npublic element: any, subInstructions: ElementInstructionMap,\npublic errors: any[],\npublic timelines: TimelineBuilder[], initialTimeline: TimelineBuilder = null) {\n    this.currentTimeline = initialTimeline || new TimelineBuilder(element, 0);\n    timelines.push(this.currentTimeline);\n    this.subInstructions = subInstructions || new ElementInstructionMap();\n  }\n/**\n * @param {?=} element\n * @param {?=} newTime\n * @return {?}\n */\ncreateSubContext(element: any = null, newTime = 0): AnimationTimelineContext {\n    const /** @type {?} */ target = element || this.element;\n    const /** @type {?} */ context = new AnimationTimelineContext(\n        target, this.subInstructions, this.errors, this.timelines,\n        this.currentTimeline.fork(target, newTime));\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n    context.locals = this.locals ? copyObj(this.locals) : null;\n    context.currentQueryIndex = this.currentQueryIndex;\n    context.currentQueryTotal = this.currentQueryTotal;\n    context.parentContext = this;\n    this.subContextCount++;\n    return context;\n  }\n/**\n * @param {?=} newTime\n * @return {?}\n */\ntransformIntoNewTimeline(newTime = 0) {\n    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n/**\n * @param {?} instruction\n * @param {?} timings\n * @return {?}\n */\nappendInstructionToTimeline(instruction: AnimationTimelineInstruction, timings: AnimateTimings):\n      AnimateTimings {\n    const /** @type {?} */ updatedTimings: AnimateTimings = {\n      duration: timings ? timings.duration : instruction.duration,\n      delay: this.currentTimeline.currentTime + (timings ? timings.delay : 0) + instruction.delay,\n      easing: timings ? timings.easing : instruction.easing\n    };\n    const /** @type {?} */ builder = new SubTimelineBuilder(\n        instruction.element, instruction.keyframes, instruction.preStyleProps,\n        instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n    this.timelines.push(builder);\n    return updatedTimings;\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nincrementTime(time: number) {\n    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n  }\n}\n\nfunction AnimationTimelineContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTimelineContext.prototype.parentContext;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentTimeline;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationTimelineContext.prototype.previousNode;\n/** @type {?} */\nAnimationTimelineContext.prototype.subContextCount;\n/** @type {?} */\nAnimationTimelineContext.prototype.locals;\n/** @type {?} */\nAnimationTimelineContext.prototype.subInstructions;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentQueryIndex;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentQueryTotal;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentStaggerTime;\n/** @type {?} */\nAnimationTimelineContext.prototype.element;\n/** @type {?} */\nAnimationTimelineContext.prototype.errors;\n/** @type {?} */\nAnimationTimelineContext.prototype.timelines;\n}\n\nexport class AnimationTimelineBuilderVisitor implements AnimationAstVisitor {\n/**\n * @param {?} rootElement\n * @param {?} ast\n * @param {?} startingStyles\n * @param {?} finalStyles\n * @param {?} locals\n * @param {?=} subInstructions\n * @param {?=} errors\n * @return {?}\n */\nbuildKeyframes(\n      rootElement: any, ast: AnimationAst, startingStyles: ɵStyleData, finalStyles: ɵStyleData,\n      locals: {[varName: string]: string | number | boolean},\n      subInstructions: ElementInstructionMap = null,\n      errors: any[]): AnimationTimelineInstruction[] {\n    const /** @type {?} */ context = new AnimationTimelineContext(rootElement, subInstructions, errors, []);\n    if (locals && Object.keys(locals).length == 0) {\n      locals = null;\n    }\n    context.locals = locals;\n    context.currentTimeline.setStyles([startingStyles], null, false, context.errors, locals);\n\n    ast.visit(this, context);\n\n    // this checks to see if an actual animation happened\n    const /** @type {?} */ timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n    if (timelines.length && Object.keys(finalStyles).length) {\n      const /** @type {?} */ tl = timelines[timelines.length - 1];\n      if (!tl.allowOnlyTimelineStyles()) {\n        tl.setStyles([finalStyles], null, false, context.errors, locals);\n      }\n    }\n\n    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) :\n                              [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTrigger(ast: AnimationTriggerAst, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitState(ast: AnimationStateAst, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTransition(ast: AnimationTransitionAst, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimateChild(ast: AnimationAnimateChildAst, context: any): any {\n    const /** @type {?} */ innerContext = context.createSubContext();\n    innerContext.locals = ast.locals ? copyObj(ast.locals) : context.locals;\n    if (ast.animation) {\n      innerContext.transformIntoNewTimeline();\n      this.visitReference(ast.animation, innerContext);\n      context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n    } else {\n      const /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);\n      if (elementInstructions) {\n        this._visitSubInstructions(elementInstructions, ast.timings, context);\n      }\n    }\n    context.previousNode = ast;\n  }\n/**\n * @param {?} instructions\n * @param {?} timings\n * @param {?} context\n * @return {?}\n */\nprivate _visitSubInstructions(\n      instructions: AnimationTimelineInstruction[], timings: AnimateTimings,\n      context: AnimationTimelineContext) {\n    if (timings && timings.duration === 0) return;\n    const /** @type {?} */ rootElement = context.element;\n    const /** @type {?} */ startTime = context.currentTimeline.currentTime;\n    let /** @type {?} */ furthestTime = startTime;\n    instructions.forEach(instruction => {\n      const /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, timings);\n      furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n    });\n\n    // create an animation for the element containing sub animations which contains\n    // keyframes from start to finish to cover the entire animation so the player\n    // for the container element will complete once everything below has finished\n    if (startTime != furthestTime) {\n      // there is no need to set a delay here since it is already known by the inner\n      // timeline start time (it is updated within the appendInstructionToTimeline code)\n      const /** @type {?} */ delay = 0;\n      const /** @type {?} */ parentTimings = {duration: furthestTime - startTime, delay, easing: ''};\n\n      const /** @type {?} */ keyframes = [{offset: 0}, {offset: 1}];\n      const /** @type {?} */ parentInstruction = createTimelineInstruction(\n          rootElement, keyframes, [], [], parentTimings.duration, delay, '', true);\n      context.appendInstructionToTimeline(parentInstruction, parentTimings);\n\n      context.transformIntoNewTimeline(furthestTime);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitReference(ast: AnimationReferenceAst, context: AnimationTimelineContext) {\n    // we traverse over all of the DEFAULT local values defined\n    // in the `animation()` declaration. This way if the user has\n    // not provided them in the `animateChild()` call (which is called\n    // just before this then it will substitute them in\n    if (ast.locals) {\n      context.locals = context.locals || {};\n      Object.keys(ast.locals).forEach(varName => {\n        if (!context.locals.hasOwnProperty(varName)) {\n          context.locals[varName] = ast.locals[varName];\n        }\n      });\n    }\n\n    ast.animation.visit(this, context);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSequence(ast: AnimationSequenceAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ subContextCount = context.subContextCount;\n    if (context.previousNode instanceof AnimationStyleAst) {\n      context.currentTimeline.forwardFrame();\n      context.currentTimeline.snapshotCurrentStyles();\n      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    }\n\n    ast.steps.forEach(s => s.visit(this, context));\n\n    // this means that some animation function within the sequence\n    // ended up creating a sub timeline (which means the current\n    // timeline cannot overlap with the contents of the sequence)\n    if (context.subContextCount > subContextCount) {\n      context.transformIntoNewTimeline();\n    }\n\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitGroup(ast: AnimationGroupAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ innerTimelines: TimelineBuilder[] = [];\n    let /** @type {?} */ furthestTime = context.currentTimeline.currentTime;\n    ast.steps.forEach(s => {\n      const /** @type {?} */ innerContext = context.createSubContext();\n      s.visit(this, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n\n    // this operation is run after the AST loop because otherwise\n    // if the parent timeline's collected styles were updated then\n    // it would pass in invalid data into the new-to-be forked items\n    innerTimelines.forEach(\n        timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTiming(ast: AnimationTimingAst, context: AnimationTimelineContext): AnimateTimings {\n    if (ast instanceof DynamicAnimationTimingAst) {\n      const /** @type {?} */ strValue = interpolateStyleLocals(ast.value, context.locals, context.errors);\n      return resolveTimingValue(strValue, context.errors);\n    } else {\n      return {duration: ast.duration, delay: ast.delay, easing: ast.easing};\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(ast: AnimationAnimateAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ timings = context.currentAnimateTimings = this.visitTiming(ast.timings, context);\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    const /** @type {?} */ style = ast.style;\n    if (style instanceof AnimationKeyframesSequenceAst) {\n      this.visitKeyframeSequence(style, context);\n    } else {\n      context.incrementTime(timings.duration);\n      this.visitStyle( /** @type {?} */((style as AnimationStyleAst)), context);\n    }\n\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStyle(ast: AnimationStyleAst, context: AnimationTimelineContext) {\n    // this is a special case when a style() call is issued directly after\n    // a call to animate(). If the clock is not forwarded by one frame then\n    // the style() calls will be merged into the previous animate() call\n    // which is incorrect.\n    if (!context.currentAnimateTimings && context.previousNode instanceof AnimationAnimateAst) {\n      context.currentTimeline.forwardFrame();\n    }\n\n    const /** @type {?} */ easing =\n        (context.currentAnimateTimings && context.currentAnimateTimings.easing) || ast.easing;\n    this._applyStyles(ast.styles, easing, ast.isEmptyStep, context);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} styles\n * @param {?} easing\n * @param {?} treatAsEmptyStep\n * @param {?} context\n * @return {?}\n */\nprivate _applyStyles(\n      styles: (ɵStyleData|string)[], easing: string, treatAsEmptyStep: boolean,\n      context: AnimationTimelineContext): void {\n    context.currentTimeline.setStyles(\n        styles, easing, treatAsEmptyStep, context.errors, context.locals);\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyframeSequence(ast: AnimationKeyframesSequenceAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ startTime = context.currentTimeline.duration;\n    const /** @type {?} */ duration = context.currentAnimateTimings.duration;\n    const /** @type {?} */ innerContext = context.createSubContext();\n    const /** @type {?} */ innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = context.currentAnimateTimings.easing;\n\n    ast.styles.forEach(step => {\n      innerTimeline.forwardTime(step.offset * duration);\n      this._applyStyles(step.styles, step.easing, false, innerContext);\n    });\n\n    // this will ensure that the parent timeline gets all the styles from\n    // the child even if the new timeline below is not used\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n\n    // we do this because the window between this timeline and the sub timeline\n    // should ensure that the styles within are exactly the same as they were before\n    context.transformIntoNewTimeline(startTime + duration);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitQuery(ast: AnimationQueryAst, context: AnimationTimelineContext) {\n    // in the event that the first step before this is a style step we need\n    // to ensure the styles are applied before the children are animated\n    const /** @type {?} */ startTime = context.currentTimeline.currentTime;\n\n    if (context.previousNode instanceof AnimationStyleAst ||\n        (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length)) {\n      context.currentTimeline.forwardFrame();\n      context.currentTimeline.snapshotCurrentStyles();\n      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    }\n\n    let /** @type {?} */ furthestTime = startTime;\n    const /** @type {?} */ elms = invokeQuery(context.element, ast.selector, ast.multi, ast.includeSelf);\n\n    context.currentQueryTotal = elms.length;\n    let /** @type {?} */ sameElementTimeline: TimelineBuilder = null;\n    elms.forEach((element, i) => {\n\n      context.currentQueryIndex = i;\n      const /** @type {?} */ innerContext = context.createSubContext(element);\n\n      let /** @type {?} */ tl = innerContext.currentTimeline;\n      if (element === context.element) {\n        sameElementTimeline = tl;\n      }\n\n      const /** @type {?} */ startTime = tl.currentTime;\n\n      ast.animation.visit(this, innerContext);\n\n      tl = innerContext.currentTimeline;\n      let /** @type {?} */ endTime = tl.currentTime;\n\n      // this means that the query itself ONLY took on styling calls. When this\n      // happens we need to gaurantee that the styles are applied on screen.\n      if (innerContext.previousNode instanceof AnimationStyleAst && startTime == endTime) {\n        tl.forwardFrame();\n        tl.snapshotCurrentStyles();\n        endTime = tl.currentTime;\n        innerContext.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n      }\n\n      furthestTime = Math.max(furthestTime, endTime);\n    });\n\n    context.currentQueryIndex = 0;\n    context.currentQueryTotal = 0;\n    context.transformIntoNewTimeline(furthestTime);\n\n    if (sameElementTimeline) {\n      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStagger(ast: AnimationStaggerAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ parentContext = context.parentContext;\n    const /** @type {?} */ tl = context.currentTimeline;\n    const /** @type {?} */ timings = ast.timings;\n    const /** @type {?} */ duration = Math.abs(timings.duration);\n    const /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);\n    let /** @type {?} */ delay = duration * context.currentQueryIndex;\n\n    let /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n    switch (staggerTransformer) {\n      case 'reverse':\n        delay = maxTime - delay;\n        break;\n      case 'full':\n        delay = parentContext.currentStaggerTime;\n        break;\n    }\n\n    if (delay) {\n      context.currentTimeline.delayNextStep(delay);\n    }\n\n    const /** @type {?} */ startingTime = context.currentTimeline.currentTime;\n    ast.animation.visit(this, context);\n    context.previousNode = ast;\n\n    // time = duration + delay\n    // the reason why this computation is so complex is because\n    // the inner timeline may either have a delay value or a stretched\n    // keyframe depending on if a subtimeline is not used or is used.\n    parentContext.currentStaggerTime =\n        (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitWait(ast: AnimationWaitAst, context: AnimationTimelineContext) {\n    if (ast.delay) {\n      if (context.previousNode instanceof AnimationStyleAst) {\n        context.currentTimeline.forwardFrame();\n        context.currentTimeline.snapshotCurrentStyles();\n        context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n      }\n\n      context.currentTimeline.delayNextStep(ast.delay);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n    if (ast.animation) {\n      ast.animation.visit(this, context);\n    }\n    context.previousNode = ast;\n  }\n}\nexport class TimelineBuilder {\npublic duration: number = 0;\npublic easing: string = '';\nprivate _previousKeyframe: ɵStyleData = {};\nprivate _currentKeyframe: ɵStyleData;\nprivate _keyframes = new Map<number, ɵStyleData>();\nprivate _styleSummary: {[prop: string]: StyleAtTime} = {};\nprivate _localTimelineStyles: ɵStyleData;\nprivate _globalTimelineStyles: ɵStyleData;\nprivate _backFill: ɵStyleData = {};\nprivate _currentEmptyStepKeyframe: ɵStyleData = null;\n/**\n * @param {?} element\n * @param {?} startTime\n * @param {?=} _elementTimelineStylesLookup\n */\nconstructor(\npublic element: any,\npublic startTime: number,\nprivate _elementTimelineStylesLookup?: Map<any, ɵStyleData>) {\n    if (!this._elementTimelineStylesLookup) {\n      this._elementTimelineStylesLookup = new Map<any, ɵStyleData>();\n    }\n    this._localTimelineStyles = Object.create(this._backFill, {});\n    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n    }\n    this._loadKeyframe();\n  }\n/**\n * @return {?}\n */\ncontainsAnimation(): boolean { return this._keyframes.size > 1; }\n/**\n * @return {?}\n */\ngetCurrentStyleProperties(): string[] { return Object.keys(this._currentKeyframe); }\n/**\n * @return {?}\n */\nget currentTime() { return this.startTime + this.duration; }\n/**\n * @param {?} delay\n * @return {?}\n */\ndelayNextStep(delay: number) {\n    if (this.duration == 0) {\n      this.startTime += delay;\n    } else {\n      this.forwardTime(this.currentTime + delay);\n    }\n  }\n/**\n * @param {?} duration\n * @return {?}\n */\nwarpTiming(duration: number) { this.duration = duration; }\n/**\n * @param {?} element\n * @param {?=} currentTime\n * @return {?}\n */\nfork(element: any, currentTime = 0): TimelineBuilder {\n    return new TimelineBuilder(\n        element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\n  }\n/**\n * @return {?}\n */\nprivate _loadKeyframe() {\n    if (this._currentKeyframe) {\n      this._previousKeyframe = this._currentKeyframe;\n    }\n    this._currentKeyframe = this._keyframes.get(this.duration);\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = Object.create(this._backFill, {});\n      this._keyframes.set(this.duration, this._currentKeyframe);\n    }\n  }\n/**\n * @return {?}\n */\nforwardFrame() {\n    this.duration++;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nforwardTime(time: number) {\n    this.duration = time;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} prop\n * @param {?} value\n * @return {?}\n */\nprivate _updateStyle(prop: string, value: string|number) {\n    if (prop != 'easing') {\n      this._localTimelineStyles[prop] = value;\n      this._globalTimelineStyles[prop] = value;\n      this._styleSummary[prop] = {time: this.currentTime, value};\n    }\n  }\n/**\n * @return {?}\n */\nallowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe; }\n/**\n * @param {?} input\n * @param {?} easing\n * @param {?} treatAsEmptyStep\n * @param {?} errors\n * @param {?=} locals\n * @return {?}\n */\nsetStyles(\n      input: (ɵStyleData|string)[], easing: string, treatAsEmptyStep: boolean, errors: any[],\n      locals: {[varName: string]: string | number | boolean} = null) {\n    if (easing) {\n      this._previousKeyframe['easing'] = easing;\n    }\n\n    if (treatAsEmptyStep) {\n      // special case for animate(duration):\n      // all missing styles are filled with a `*` value then\n      // if any destination styles are filled in later on the same\n      // keyframe then they will override the overridden styles\n      // We use `_globalTimelineStyles` here because there may be\n      // styles in previous keyframes that are not present in this timeline\n      Object.keys(this._globalTimelineStyles).forEach(prop => {\n        this._backFill[prop] = this._globalTimelineStyles[prop] || AUTO_STYLE;\n        this._currentKeyframe[prop] = AUTO_STYLE;\n      });\n      this._currentEmptyStepKeyframe = this._currentKeyframe;\n    } else {\n      const /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);\n      Object.keys(styles).forEach(prop => {\n        let /** @type {?} */ val = styles[prop];\n        if (locals) {\n          val = interpolateStyleLocals(val, locals, errors);\n        }\n\n        this._currentKeyframe[prop] = val;\n        if (!this._localTimelineStyles[prop]) {\n          this._backFill[prop] = this._globalTimelineStyles.hasOwnProperty(prop) ?\n              this._globalTimelineStyles[prop] :\n              AUTO_STYLE;\n        }\n        this._updateStyle(prop, val);\n      });\n\n      Object.keys(this._localTimelineStyles).forEach(prop => {\n        if (!this._currentKeyframe.hasOwnProperty(prop)) {\n          this._currentKeyframe[prop] = this._localTimelineStyles[prop];\n        }\n      });\n    }\n  }\n/**\n * @return {?}\n */\nsnapshotCurrentStyles() { copyStyles(this._localTimelineStyles, false, this._currentKeyframe); }\n/**\n * @return {?}\n */\ngetFinalKeyframe() { return this._keyframes.get(this.duration); }\n/**\n * @return {?}\n */\nget properties() {\n    const /** @type {?} */ properties: string[] = [];\n    for (let /** @type {?} */ prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n/**\n * @param {?} timeline\n * @return {?}\n */\nmergeTimelineCollectedStyles(timeline: TimelineBuilder) {\n    Object.keys(timeline._styleSummary).forEach(prop => {\n      const /** @type {?} */ details0 = this._styleSummary[prop];\n      const /** @type {?} */ details1 = timeline._styleSummary[prop];\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nbuildKeyframes(): AnimationTimelineInstruction {\n    const /** @type {?} */ preStyleProps = new Set<string>();\n    const /** @type {?} */ postStyleProps = new Set<string>();\n    const /** @type {?} */ finalKeyframes: ɵStyleData[] = [];\n    this._keyframes.forEach((keyframe, time) => {\n      const /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);\n      Object.keys(finalKeyframe).forEach(prop => {\n        const /** @type {?} */ value = finalKeyframe[prop];\n        if (value == PRE_STYLE) {\n          preStyleProps.add(prop);\n        } else if (value == AUTO_STYLE) {\n          postStyleProps.add(prop);\n        }\n      });\n      finalKeyframe['offset'] = time / this.duration;\n      finalKeyframes.push(finalKeyframe);\n    });\n\n    const /** @type {?} */ preProps: string[] = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];\n    const /** @type {?} */ postProps: string[] = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];\n\n    return createTimelineInstruction(\n        this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime,\n        this.easing, false);\n  }\n}\n\nfunction TimelineBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nTimelineBuilder.prototype.duration;\n/** @type {?} */\nTimelineBuilder.prototype.easing;\n/** @type {?} */\nTimelineBuilder.prototype._previousKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._currentKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._keyframes;\n/** @type {?} */\nTimelineBuilder.prototype._styleSummary;\n/** @type {?} */\nTimelineBuilder.prototype._localTimelineStyles;\n/** @type {?} */\nTimelineBuilder.prototype._globalTimelineStyles;\n/** @type {?} */\nTimelineBuilder.prototype._backFill;\n/** @type {?} */\nTimelineBuilder.prototype._currentEmptyStepKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype.element;\n/** @type {?} */\nTimelineBuilder.prototype.startTime;\n/** @type {?} */\nTimelineBuilder.prototype._elementTimelineStylesLookup;\n}\n\nclass SubTimelineBuilder extends TimelineBuilder {\npublic timings: AnimateTimings;\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @param {?} timings\n * @param {?=} _stretchStartingKeyframe\n */\nconstructor(\npublic element: any,\npublic keyframes: ɵStyleData[],\npublic preStyleProps: string[],\npublic postStyleProps: string[], timings: AnimateTimings,\nprivate _stretchStartingKeyframe: boolean = false) {\n    super(element, timings.delay);\n    this.timings = {duration: timings.duration, delay: timings.delay, easing: timings.easing};\n  }\n/**\n * @return {?}\n */\ncontainsAnimation(): boolean { return this.keyframes.length > 1; }\n/**\n * @return {?}\n */\nbuildKeyframes(): AnimationTimelineInstruction {\n    let /** @type {?} */ keyframes = this.keyframes;\n    let {delay, duration, easing} = this.timings;\n    if (this._stretchStartingKeyframe && delay) {\n      const /** @type {?} */ newKeyframes: ɵStyleData[] = [];\n      const /** @type {?} */ totalTime = duration + delay;\n      const /** @type {?} */ startingGap = delay / totalTime;\n\n      // the original starting keyframe now starts once the delay is done\n      const /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);\n      newFirstKeyframe['offset'] = 0;\n      newKeyframes.push(newFirstKeyframe);\n\n      const /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);\n      oldFirstKeyframe['offset'] = roundOffset(startingGap);\n      newKeyframes.push(oldFirstKeyframe);\n\n      /*\n        When the keyframe is stretched then it means that the delay before the animation\n        starts is gone. Instead the first keyframe is placed at the start of the animation\n        and it is then copied to where it starts when the original delay is over. This basically\n        means nothing animates during that delay, but the styles are still renderered. For this\n        to work the original offset values that exist in the original keyframes must be \"warped\"\n        so that they can take the new keyframe + delay into account.\n\n        delay=1000, duration=1000, keyframes = 0 .5 1\n\n        turns into\n\n        delay=0, duration=2000, keyframes = 0 .33 .66 1\n       */\n\n      // offsets between 1 ... n -1 are all warped by the keyframe stretch\n      const /** @type {?} */ limit = keyframes.length - 1;\n      for (let /** @type {?} */ i = 1; i <= limit; i++) {\n        let /** @type {?} */ kf = copyStyles(keyframes[i], false);\n        const /** @type {?} */ oldOffset = /** @type {?} */(( kf['offset'] as number));\n        const /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;\n        kf['offset'] = roundOffset(timeAtKeyframe / totalTime);\n        newKeyframes.push(kf);\n      }\n\n      // the new starting keyframe should be added at the start\n      duration = totalTime;\n      delay = 0;\n      easing = '';\n\n      keyframes = newKeyframes;\n    }\n\n    return createTimelineInstruction(\n        this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing,\n        true);\n  }\n}\n\nfunction SubTimelineBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nSubTimelineBuilder.prototype.timings;\n/** @type {?} */\nSubTimelineBuilder.prototype.element;\n/** @type {?} */\nSubTimelineBuilder.prototype.keyframes;\n/** @type {?} */\nSubTimelineBuilder.prototype.preStyleProps;\n/** @type {?} */\nSubTimelineBuilder.prototype.postStyleProps;\n/** @type {?} */\nSubTimelineBuilder.prototype._stretchStartingKeyframe;\n}\n\n/**\n * @param {?} rootElement\n * @param {?} selector\n * @param {?} multi\n * @param {?} includeSelf\n * @return {?}\n */\nfunction invokeQuery(\n    rootElement: any, selector: string, multi: boolean, includeSelf: boolean): any[] {\n  let /** @type {?} */ results: any[] = [];\n  if (includeSelf) {\n    results.push(rootElement);\n  }\n  if (multi) {\n    results.push(...rootElement.querySelectorAll(selector));\n  } else if (results.length == 0) {\n    const /** @type {?} */ elm = rootElement.querySelector(selector);\n    if (elm) {\n      results.push(elm);\n    }\n  }\n  return results;\n}\n/**\n * @param {?} offset\n * @param {?=} decimalPoints\n * @return {?}\n */\nfunction roundOffset(offset: number, decimalPoints = 3): number {\n  const /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);\n  return Math.round(offset * mult) / mult;\n}\n/**\n * @param {?} input\n * @param {?} allStyles\n * @return {?}\n */\nfunction flattenStyles(input: (ɵStyleData | string)[], allStyles: ɵStyleData) {\n  const /** @type {?} */ styles: ɵStyleData = {};\n  let /** @type {?} */ allProperties: string[];\n  input.forEach(token => {\n    if (token === '*') {\n      allProperties = allProperties || Object.keys(allStyles);\n      allProperties.forEach(prop => { styles[prop] = AUTO_STYLE; });\n    } else {\n      copyStyles( /** @type {?} */((token as ɵStyleData)), false, styles);\n    }\n  });\n  return styles;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, ɵStyleData} from '@angular/animations';\nimport {normalizeStyles} from '../util';\nimport {AnimationAst} from './animation_ast';\nimport {buildAnimationAst} from './animation_ast_builder';\nimport {buildAnimationTimelines} from './animation_timeline_builder';\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\nexport class Animation {\nprivate _animationAst: AnimationAst;\n/**\n * @param {?} input\n */\nconstructor(input: AnimationMetadata|AnimationMetadata[]) {\n    const errors: any[] = [];\n    const ast = buildAnimationAst(input, errors);\n    if (errors.length) {\n      const errorMessage = `animation validation failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n    this._animationAst = ast;\n  }\n/**\n * @param {?} element\n * @param {?} startingStyles\n * @param {?} destinationStyles\n * @param {?} locals\n * @param {?=} subInstructions\n * @return {?}\n */\nbuildTimelines(\n      element: any, startingStyles: ɵStyleData|ɵStyleData[],\n      destinationStyles: ɵStyleData|ɵStyleData[], locals: {[key: string]: any},\n      subInstructions: ElementInstructionMap = null): AnimationTimelineInstruction[] {\n    const /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */((\n                                                  <ɵStyleData>startingStyles));\n    const /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */((\n                                                    <ɵStyleData>destinationStyles));\n    const /** @type {?} */ errors: any = [];\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const /** @type {?} */ result = buildAnimationTimelines(\n        element, this._animationAst, start, dest, locals, subInstructions, errors);\n    if (errors.length) {\n      const /** @type {?} */ errorMessage = `animation building failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n    return result;\n  }\n}\n\nfunction Animation_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimation.prototype._animationAst;\n}\n\n","\n/**\n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationStyleNormalizer {\n/**\n * @abstract\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]) {}\n/**\n * @abstract\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]) {}\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class NoopAnimationStyleNormalizer {\n/**\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]): string { return propertyName; }\n/**\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]): string {\n    return /** @type {?} */(( <any>value));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationStyleNormalizer} from './animation_style_normalizer';\nexport class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {\n/**\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]): string {\n    return dashCaseToCamelCase(propertyName);\n  }\n/**\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]): string {\n    let /** @type {?} */ unit: string = '';\n    const /** @type {?} */ strVal = value.toString().trim();\n\n    if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {\n      if (typeof value === 'number') {\n        unit = 'px';\n      } else {\n        const /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errors.push(`Please provide a CSS unit value for ${userProvidedProperty}:${value}`);\n        }\n      }\n    }\n    return strVal + unit;\n  }\n}\n\nconst /** @type {?} */ DIMENSIONAL_PROP_MAP = makeBooleanMap(\n    'width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent'\n        .split(','));\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction makeBooleanMap(keys: string[]): {[key: string]: boolean} {\n  const /** @type {?} */ map: {[key: string]: boolean} = {};\n  keys.forEach(key => map[key] = true);\n  return map;\n}\n\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\n\nimport {getOrSetAsInMap} from '../render/shared';\nimport {iteratorToArray} from '../util';\n\nimport {AnimationTransitionAst} from './animation_ast';\nimport {buildAnimationTimelines} from './animation_timeline_builder';\nimport {TransitionMatcherFn} from './animation_transition_expr';\nimport {AnimationTransitionInstruction, createTransitionInstruction} from './animation_transition_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\nexport class AnimationTransitionFactory {\n/**\n * @param {?} _triggerName\n * @param {?} ast\n * @param {?} _stateStyles\n */\nconstructor(\nprivate _triggerName: string,\npublic ast: AnimationTransitionAst,\nprivate _stateStyles: {[stateName: string]: ɵStyleData}) {}\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nmatch(currentState: any, nextState: any): boolean {\n    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);\n  }\n/**\n * @param {?} element\n * @param {?} currentState\n * @param {?} nextState\n * @param {?=} locals\n * @param {?=} subInstructions\n * @return {?}\n */\nbuild(\n      element: any, currentState: any, nextState: any,\n      locals: {[varName: string]: string | number} = null,\n      subInstructions: ElementInstructionMap = null): AnimationTransitionInstruction {\n    let /** @type {?} */ animationLocals: {[varName: string]: string | number | boolean} = null;\n    if (this.ast.locals) {\n      animationLocals = /** @type {?} */(( (locals || {}) as{[varName: string]: string | number | boolean}));\n      Object.keys(this.ast.locals).forEach(prop => {\n        if (!animationLocals.hasOwnProperty(prop)) {\n          animationLocals[prop] = this.ast.locals[prop];\n        }\n      });\n    }\n\n    const /** @type {?} */ backupStateStyles = this._stateStyles['*'] || {};\n    const /** @type {?} */ currentStateStyles = this._stateStyles[currentState] || backupStateStyles;\n    const /** @type {?} */ nextStateStyles = this._stateStyles[nextState] || backupStateStyles;\n\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ timelines = buildAnimationTimelines(\n        element, this.ast.animation, currentStateStyles, nextStateStyles, animationLocals,\n        subInstructions, errors);\n\n    if (errors.length) {\n      const /** @type {?} */ errorMessage = `animation building failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n\n    const /** @type {?} */ preStyleMap = new Map<any, {[prop: string]: boolean}>();\n    const /** @type {?} */ postStyleMap = new Map<any, {[prop: string]: boolean}>();\n    const /** @type {?} */ queriedElements = new Set<any>();\n    timelines.forEach(tl => {\n      const /** @type {?} */ elm = tl.element;\n      const /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});\n      tl.preStyleProps.forEach(prop => preProps[prop] = true);\n\n      const /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});\n      tl.postStyleProps.forEach(prop => postProps[prop] = true);\n\n      if (elm !== element) {\n        queriedElements.add(elm);\n      }\n    });\n\n    const /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());\n    return createTransitionInstruction(\n        element, this._triggerName, currentState, nextState, nextState === 'void',\n        currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap,\n        postStyleMap);\n  }\n}\n\nfunction AnimationTransitionFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTransitionFactory.prototype._triggerName;\n/** @type {?} */\nAnimationTransitionFactory.prototype.ast;\n/** @type {?} */\nAnimationTransitionFactory.prototype._stateStyles;\n}\n\n/**\n * @param {?} matchFns\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nfunction oneOrMoreTransitionsMatch(\n    matchFns: TransitionMatcherFn[], currentState: any, nextState: any): boolean {\n  return matchFns.some(fn => fn(currentState, nextState));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\n\nimport {copyStyles} from '../util';\n\nimport {AnimationSequenceAst, AnimationTransitionAst, AnimationTriggerAst} from './animation_ast';\nimport {AnimationTransitionFactory} from './animation_transition_factory';\n/**\n * \\@experimental Animation support is experimental.\n * @param {?} name\n * @param {?} ast\n * @return {?}\n */\nexport function buildTrigger(name: string, ast: AnimationTriggerAst): AnimationTrigger {\n  return new AnimationTrigger(name, ast);\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class AnimationTrigger {\npublic transitionFactories: AnimationTransitionFactory[] = [];\npublic fallbackTransition: AnimationTransitionFactory;\npublic states: {[stateName: string]: ɵStyleData} = {};\n/**\n * @param {?} name\n * @param {?} ast\n */\nconstructor(public name: string,\npublic ast: AnimationTriggerAst) {\n    ast.states.forEach(ast => {\n      const obj = this.states[ast.name] = {};\n      ast.style.styles.forEach(styleTuple => {\n        if (typeof styleTuple == 'object') {\n          copyStyles(styleTuple as ɵStyleData, false, obj)\n        }\n      });\n    });\n\n    ast.transitions.forEach(ast => {\n      this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));\n    });\n\n    this.fallbackTransition = createFallbackTransition(name, this.states);\n  }\n/**\n * @return {?}\n */\nget containsQueries() { return this.ast.queryCount > 0; }\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nmatchTransition(currentState: any, nextState: any): AnimationTransitionFactory {\n    return this.transitionFactories.find(f => f.match(currentState, nextState));\n  }\n}\n\nfunction AnimationTrigger_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTrigger.prototype.transitionFactories;\n/** @type {?} */\nAnimationTrigger.prototype.fallbackTransition;\n/** @type {?} */\nAnimationTrigger.prototype.states;\n/** @type {?} */\nAnimationTrigger.prototype.name;\n/** @type {?} */\nAnimationTrigger.prototype.ast;\n}\n\n/**\n * @param {?} triggerName\n * @param {?} states\n * @return {?}\n */\nfunction createFallbackTransition(\n    triggerName: string, states: {[stateName: string]: ɵStyleData}): AnimationTransitionFactory {\n  const /** @type {?} */ matchers = [(fromState: any, toState: any) => true];\n  const /** @type {?} */ animation = new AnimationSequenceAst([]);\n  const /** @type {?} */ transition = new AnimationTransitionAst(matchers, animation, {});\n  return new AnimationTransitionFactory(triggerName, transition, states);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationMetadata, AnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationAst} from '../dsl/animation_ast';\nimport {buildAnimationAst} from '../dsl/animation_ast_builder';\nimport {buildAnimationTimelines} from '../dsl/animation_timeline_builder';\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst /** @type {?} */ EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();\nexport class TimelineAnimationEngine {\nprivate _animations: {[id: string]: AnimationAst} = {};\nprivate _playersById: {[id: string]: AnimationPlayer} = {};\npublic players: AnimationPlayer[] = [];\n/**\n * @param {?} _driver\n * @param {?} _normalizer\n */\nconstructor(private _driver: AnimationDriver,\nprivate _normalizer: AnimationStyleNormalizer) {}\n/**\n * @param {?} id\n * @param {?} metadata\n * @return {?}\n */\nregister(id: string, metadata: AnimationMetadata|AnimationMetadata[]) {\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ ast = buildAnimationAst(metadata, errors);\n    if (errors.length) {\n      throw new Error(\n          `Unable to build the animation due to the following errors: ${errors.join(\"\\n\")}`);\n    } else {\n      this._animations[id] = ast;\n    }\n  }\n/**\n * @param {?} i\n * @param {?} preStyles\n * @param {?} postStyles\n * @return {?}\n */\nprivate _buildPlayer(\n      i: AnimationTimelineInstruction, preStyles: ɵStyleData,\n      postStyles: ɵStyleData): AnimationPlayer {\n    const /** @type {?} */ element = i.element;\n    const /** @type {?} */ keyframes = normalizeKeyframes(\n        this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);\n    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);\n  }\n/**\n * @param {?} id\n * @param {?} element\n * @param {?=} locals\n * @return {?}\n */\ncreate(id: string, element: any, locals: {[key: string]: string | number} = {}): AnimationPlayer {\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ ast = this._animations[id];\n    let /** @type {?} */ instructions: AnimationTimelineInstruction[];\n\n    const /** @type {?} */ autoStylesMap = new Map<any, ɵStyleData>();\n\n    if (ast) {\n      instructions =\n          buildAnimationTimelines(element, ast, {}, {}, locals, EMPTY_INSTRUCTION_MAP, errors);\n      instructions.forEach(inst => {\n        const /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});\n        inst.postStyleProps.forEach(prop => styles[prop] = null);\n      });\n    } else {\n      errors.push('The requested animation doesn\\'t exist or has already been destroyed');\n    }\n\n    if (errors.length) {\n      throw new Error(\n          `Unable to create the animation due to the following errors: ${errors.join(\"\\n\")}`);\n    }\n\n    autoStylesMap.forEach((styles, element) => {\n      Object.keys(styles).forEach(\n          prop => { styles[prop] = this._driver.computeStyle(element, prop, AUTO_STYLE); });\n    });\n\n    const /** @type {?} */ players = instructions.map(i => {\n      const /** @type {?} */ styles = autoStylesMap.get(i.element);\n      return this._buildPlayer(i, {}, styles);\n    });\n    const /** @type {?} */ player = optimizeGroupPlayer(players);\n    this._playersById[id] = player;\n    player.onDestroy(() => this.destroy(id));\n\n    this.players.push(player);\n    return player;\n  }\n/**\n * @param {?} id\n * @return {?}\n */\ndestroy(id: string) {\n    const /** @type {?} */ player = this._getPlayer(id);\n    player.destroy();\n    delete this._playersById[id];\n    const /** @type {?} */ index = this.players.indexOf(player);\n    if (index >= 0) {\n      this.players.splice(index, 1);\n    }\n  }\n/**\n * @param {?} id\n * @return {?}\n */\nprivate _getPlayer(id: string): AnimationPlayer {\n    const /** @type {?} */ player = this._playersById[id];\n    if (!player) {\n      throw new Error(`Unable to find the timeline player referenced by ${id}`);\n    }\n    return player;\n  }\n/**\n * @param {?} id\n * @param {?} element\n * @param {?} eventName\n * @param {?} callback\n * @return {?}\n */\nlisten(id: string, element: string, eventName: string, callback: (event: any) => any):\n      () => void {\n    // triggerName, fromState, toState are all ignored for timeline animations\n    const /** @type {?} */ baseEvent = makeAnimationEvent(element, null, null, null);\n    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\n    return () => {};\n  }\n/**\n * @param {?} id\n * @param {?} element\n * @param {?} command\n * @param {?} args\n * @return {?}\n */\ncommand(id: string, element: any, command: string, args: any[]): void {\n    if (command == 'register') {\n      this.register(id, /** @type {?} */(( args[0] as AnimationMetadata | AnimationMetadata[])));\n      return;\n    }\n\n    if (command == 'create') {\n      const /** @type {?} */ locals = /** @type {?} */(( (args[0] || {}) as{[key: string]: string | number}));\n      this.create(id, element, locals);\n      return;\n    }\n\n    const /** @type {?} */ player = this._getPlayer(id);\n    switch (command) {\n      case 'play':\n        player.play();\n        break;\n      case 'pause':\n        player.pause();\n        break;\n      case 'reset':\n        player.reset();\n        break;\n      case 'restart':\n        player.restart();\n        break;\n      case 'finish':\n        player.finish();\n        break;\n      case 'init':\n        player.init();\n        break;\n      case 'setPosition':\n        player.setPosition(parseFloat( /** @type {?} */((args[0] as string))));\n        break;\n      case 'destroy':\n        this.destroy(id);\n        break;\n    }\n  }\n}\n\nfunction TimelineAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nTimelineAnimationEngine.prototype._animations;\n/** @type {?} */\nTimelineAnimationEngine.prototype._playersById;\n/** @type {?} */\nTimelineAnimationEngine.prototype.players;\n/** @type {?} */\nTimelineAnimationEngine.prototype._driver;\n/** @type {?} */\nTimelineAnimationEngine.prototype._normalizer;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimateTimings, ɵStyleData} from '@angular/animations';\n\nexport interface AnimationAstVisitor {\n  visitTrigger(ast: AnimationTriggerAst, context: any): any;\n  visitState(ast: AnimationStateAst, context: any): any;\n  visitTransition(ast: AnimationTransitionAst, context: any): any;\n  visitSequence(ast: AnimationSequenceAst, context: any): any;\n  visitGroup(ast: AnimationGroupAst, context: any): any;\n  visitAnimate(ast: AnimationAnimateAst, context: any): any;\n  visitStyle(ast: AnimationStyleAst, context: any): any;\n  visitKeyframeSequence(ast: AnimationKeyframesSequenceAst, context: any): any;\n  visitReference(ast: AnimationReferenceAst, context: any): any;\n  visitAnimateChild(ast: AnimationAnimateChildAst, context: any): any;\n  visitQuery(ast: AnimationQueryAst, context: any): any;\n  visitStagger(ast: AnimationStaggerAst, context: any): any;\n  visitWait(ast: AnimationWaitAst, context: any): any;\n  visitTiming(ast: AnimationTimingAst, context: any): any;\n}\n/**\n * @abstract\n */\nexport abstract class AnimationAst {\n/**\n * @abstract\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisit(ast: AnimationAstVisitor, context: any) {} }\nexport class AnimationTriggerAst extends AnimationAst {\npublic queryCount: number = 0;\npublic depCount: number = 0;\n/**\n * @param {?} name\n * @param {?} states\n * @param {?} transitions\n */\nconstructor(\npublic name: string,\npublic states: AnimationStateAst[],\npublic transitions: AnimationTransitionAst[]) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitTrigger(this, context);\n  }\n}\n\nfunction AnimationTriggerAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTriggerAst.prototype.queryCount;\n/** @type {?} */\nAnimationTriggerAst.prototype.depCount;\n/** @type {?} */\nAnimationTriggerAst.prototype.name;\n/** @type {?} */\nAnimationTriggerAst.prototype.states;\n/** @type {?} */\nAnimationTriggerAst.prototype.transitions;\n}\n\nexport class AnimationStateAst extends AnimationAst {\n/**\n * @param {?} name\n * @param {?} style\n */\nconstructor(public name: string,\npublic style: AnimationStyleAst) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitState(this, context);\n  }\n}\n\nfunction AnimationStateAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationStateAst.prototype.name;\n/** @type {?} */\nAnimationStateAst.prototype.style;\n}\n\nexport class AnimationTransitionAst extends AnimationAst {\npublic queryCount: number = 0;\npublic depCount: number = 0;\n/**\n * @param {?} matchers\n * @param {?} animation\n * @param {?} locals\n */\nconstructor(\npublic matchers: ((fromState: string, toState: string) => boolean)[],\npublic animation: AnimationAst,\npublic locals: {[varName: string]: string | number | boolean}) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitTransition(this, context);\n  }\n}\n\nfunction AnimationTransitionAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTransitionAst.prototype.queryCount;\n/** @type {?} */\nAnimationTransitionAst.prototype.depCount;\n/** @type {?} */\nAnimationTransitionAst.prototype.matchers;\n/** @type {?} */\nAnimationTransitionAst.prototype.animation;\n/** @type {?} */\nAnimationTransitionAst.prototype.locals;\n}\n\nexport class AnimationSequenceAst extends AnimationAst {\n/**\n * @param {?} steps\n */\nconstructor(public steps: AnimationAst[]) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitSequence(this, context);\n  }\n}\n\nfunction AnimationSequenceAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationSequenceAst.prototype.steps;\n}\n\nexport class AnimationGroupAst extends AnimationAst {\n/**\n * @param {?} steps\n */\nconstructor(public steps: AnimationAst[]) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitGroup(this, context);\n  }\n}\n\nfunction AnimationGroupAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationGroupAst.prototype.steps;\n}\n\nexport class AnimationAnimateAst extends AnimationAst {\n/**\n * @param {?} timings\n * @param {?} style\n */\nconstructor(\npublic timings: AnimationTimingAst,\npublic style: AnimationStyleAst|AnimationKeyframesSequenceAst) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitAnimate(this, context);\n  }\n}\n\nfunction AnimationAnimateAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationAnimateAst.prototype.timings;\n/** @type {?} */\nAnimationAnimateAst.prototype.style;\n}\n\nexport class AnimationStyleAst extends AnimationAst {\npublic isEmptyStep = false;\n/**\n * @param {?} styles\n * @param {?} easing\n * @param {?} offset\n */\nconstructor(public styles: (ɵStyleData|string)[],\npublic easing: string,\npublic offset: number) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitStyle(this, context);\n  }\n}\n\nfunction AnimationStyleAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationStyleAst.prototype.isEmptyStep;\n/** @type {?} */\nAnimationStyleAst.prototype.styles;\n/** @type {?} */\nAnimationStyleAst.prototype.easing;\n/** @type {?} */\nAnimationStyleAst.prototype.offset;\n}\n\nexport class AnimationKeyframesSequenceAst extends AnimationAst {\n/**\n * @param {?} styles\n */\nconstructor(public styles: AnimationStyleAst[]) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitKeyframeSequence(this, context);\n  }\n}\n\nfunction AnimationKeyframesSequenceAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationKeyframesSequenceAst.prototype.styles;\n}\n\nexport class AnimationReferenceAst extends AnimationAst {\n/**\n * @param {?} animation\n * @param {?} locals\n */\nconstructor(\npublic animation: AnimationAst,\npublic locals: {[varName: string]: string | number | boolean}) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitReference(this, context);\n  }\n}\n\nfunction AnimationReferenceAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationReferenceAst.prototype.animation;\n/** @type {?} */\nAnimationReferenceAst.prototype.locals;\n}\n\nexport class AnimationAnimateChildAst extends AnimationAst {\n/**\n * @param {?} timings\n * @param {?} animation\n * @param {?} locals\n */\nconstructor(\npublic timings: AnimateTimings,\npublic animation: AnimationReferenceAst,\npublic locals: {[varName: string]: string | number | boolean}) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitAnimateChild(this, context);\n  }\n}\n\nfunction AnimationAnimateChildAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationAnimateChildAst.prototype.timings;\n/** @type {?} */\nAnimationAnimateChildAst.prototype.animation;\n/** @type {?} */\nAnimationAnimateChildAst.prototype.locals;\n}\n\nexport class AnimationQueryAst extends AnimationAst {\n/**\n * @param {?} selector\n * @param {?} multi\n * @param {?} includeSelf\n * @param {?} animation\n */\nconstructor(\npublic selector: string,\npublic multi: boolean,\npublic includeSelf: boolean,\npublic animation: AnimationAst) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitQuery(this, context);\n  }\n}\n\nfunction AnimationQueryAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationQueryAst.prototype.selector;\n/** @type {?} */\nAnimationQueryAst.prototype.multi;\n/** @type {?} */\nAnimationQueryAst.prototype.includeSelf;\n/** @type {?} */\nAnimationQueryAst.prototype.animation;\n}\n\nexport class AnimationStaggerAst extends AnimationAst {\n/**\n * @param {?} timings\n * @param {?} animation\n */\nconstructor(public timings: AnimateTimings,\npublic animation: AnimationAst) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitStagger(this, context);\n  }\n}\n\nfunction AnimationStaggerAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationStaggerAst.prototype.timings;\n/** @type {?} */\nAnimationStaggerAst.prototype.animation;\n}\n\nexport class AnimationWaitAst extends AnimationAst {\n/**\n * @param {?} delay\n * @param {?=} animation\n */\nconstructor(public delay: number,\npublic animation?: AnimationAst) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitWait(this, context);\n  }\n}\n\nfunction AnimationWaitAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationWaitAst.prototype.delay;\n/** @type {?} */\nAnimationWaitAst.prototype.animation;\n}\n\nexport class AnimationTimingAst extends AnimationAst {\n/**\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n */\nconstructor(public duration: number,\npublic delay: number,\npublic easing: string) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitTiming(this, context);\n  }\n}\n\nfunction AnimationTimingAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTimingAst.prototype.duration;\n/** @type {?} */\nAnimationTimingAst.prototype.delay;\n/** @type {?} */\nAnimationTimingAst.prototype.easing;\n}\n\nexport class DynamicAnimationTimingAst extends AnimationTimingAst {\n/**\n * @param {?} value\n */\nconstructor(public value: string) { super(0, 0, ''); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AnimationAstVisitor, context: any): any {\n    return visitor.visitTiming(this, context);\n  }\n}\n\nfunction DynamicAnimationTimingAst_tsickle_Closure_declarations() {\n/** @type {?} */\nDynamicAnimationTimingAst.prototype.value;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimateTimings, AnimationAnimateChildMetadata, AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationQueryMetadata, AnimationReferenceMetadata, AnimationSequenceMetadata, AnimationStaggerMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, AnimationTriggerMetadata, AnimationWaitMetadata, style, ɵStyleData} from '@angular/animations';\n\nimport {getOrSetAsInMap} from '../render/shared';\nimport {ENTER_SELECTOR, LEAVE_SELECTOR, NG_ANIMATING_SELECTOR, NG_TRIGGER_SELECTOR, copyObj, copyStyles, normalizeAnimationEntry, resolveTimingValue, validateStyleLocals} from '../util';\n\nimport {AnimationAnimateAst, AnimationAnimateChildAst, AnimationAst, AnimationGroupAst, AnimationKeyframesSequenceAst, AnimationQueryAst, AnimationReferenceAst, AnimationSequenceAst, AnimationStaggerAst, AnimationStateAst, AnimationStyleAst, AnimationTimingAst, AnimationTransitionAst, AnimationTriggerAst, AnimationWaitAst, DynamicAnimationTimingAst} from './animation_ast';\nimport {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';\nimport {parseTransitionExpr} from './animation_transition_expr';\n/**\n * @param {?} metadata\n * @param {?} errors\n * @return {?}\n */\nexport function buildAnimationAst(\n    metadata: AnimationMetadata | AnimationMetadata[], errors: any[]): AnimationAst {\n  return new AnimationAstBuilderVisitor().build(metadata, errors);\n}\n\nconst /** @type {?} */ LEAVE_TOKEN = ':leave';\nconst /** @type {?} */ LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\nconst /** @type {?} */ ENTER_TOKEN = ':enter';\nconst /** @type {?} */ ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');\nexport class AnimationAstBuilderVisitor implements AnimationDslVisitor {\n/**\n * @param {?} metadata\n * @param {?} errors\n * @return {?}\n */\nbuild(metadata: AnimationMetadata|AnimationMetadata[], errors: any[]): AnimationAst {\n    const /** @type {?} */ context = new AnimationAstBuilderContext(errors);\n    return /** @type {?} */(( visitAnimationNode(this, normalizeAnimationEntry(metadata), context) as AnimationAst));\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitTrigger(metadata: AnimationTriggerMetadata, context: AnimationAstBuilderContext):\n      AnimationTriggerAst {\n    let /** @type {?} */ queryCount = context.queryCount = 0;\n    let /** @type {?} */ depCount = context.depCount = 0;\n    const /** @type {?} */ states: AnimationStateAst[] = [];\n    const /** @type {?} */ transitions: AnimationTransitionAst[] = [];\n    metadata.definitions.forEach(def => {\n      if (def.type == AnimationMetadataType.State) {\n        const /** @type {?} */ stateDef = /** @type {?} */(( def as AnimationStateMetadata));\n        const /** @type {?} */ name = stateDef.name;\n        name.split(/\\s*,\\s*/).forEach(n => {\n          stateDef.name = n;\n          states.push(this.visitState(stateDef, context));\n        });\n        stateDef.name = name;\n      } else if (def.type == AnimationMetadataType.Transition) {\n        const /** @type {?} */ transition = this.visitTransition( /** @type {?} */((def as AnimationTransitionMetadata)), context);\n        queryCount += transition.queryCount;\n        depCount += transition.depCount;\n        transitions.push(transition);\n      } else {\n        context.errors.push(\n            'only state() and transition() definitions can sit inside of a trigger()');\n      }\n    });\n    const /** @type {?} */ ast = new AnimationTriggerAst(metadata.name, states, transitions);\n    ast.queryCount = queryCount;\n    ast.depCount = depCount;\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitState(metadata: AnimationStateMetadata, context: AnimationAstBuilderContext):\n      AnimationStateAst {\n    return new AnimationStateAst(metadata.name, this.visitStyle(metadata.styles, context));\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitTransition(metadata: AnimationTransitionMetadata, context: AnimationAstBuilderContext):\n      AnimationTransitionAst {\n    context.queryCount = 0;\n    context.depCount = 0;\n    const /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    const /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);\n    const /** @type {?} */ ast = new AnimationTransitionAst(matchers, entry, normalizeLocals(metadata.locals));\n    ast.queryCount = context.queryCount;\n    ast.depCount = context.depCount;\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitSequence(metadata: AnimationSequenceMetadata, context: AnimationAstBuilderContext):\n      AnimationSequenceAst {\n    return new AnimationSequenceAst(metadata.steps.map(s => visitAnimationNode(this, s, context)));\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitGroup(metadata: AnimationGroupMetadata, context: AnimationAstBuilderContext):\n      AnimationGroupAst {\n    const /** @type {?} */ currentTime = context.currentTime;\n    let /** @type {?} */ furthestTime = 0;\n    const /** @type {?} */ steps = metadata.steps.map(step => {\n      context.currentTime = currentTime;\n      const /** @type {?} */ ast = visitAnimationNode(this, step, context);\n      furthestTime = Math.max(furthestTime, context.currentTime);\n      return ast;\n    });\n    context.currentTime = furthestTime;\n    return new AnimationGroupAst(steps);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(metadata: AnimationAnimateMetadata, context: AnimationAstBuilderContext):\n      AnimationAnimateAst {\n    const /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);\n    context.currentAnimateTimings = timingAst;\n\n    let /** @type {?} */ styles: AnimationStyleAst|AnimationKeyframesSequenceAst = null;\n    let /** @type {?} */ styleMetadata: AnimationMetadata = metadata.styles ? metadata.styles : style({});\n    if (styleMetadata.type == AnimationMetadataType.KeyframeSequence) {\n      styles =\n          this.visitKeyframeSequence( /** @type {?} */((styleMetadata as AnimationKeyframesSequenceMetadata)), context);\n    } else {\n      let /** @type {?} */ styleMetadata = /** @type {?} */(( metadata.styles as AnimationStyleMetadata));\n      let /** @type {?} */ isEmpty = false;\n      if (!styleMetadata) {\n        isEmpty = true;\n        const /** @type {?} */ newStyleData: {[prop: string]: string | number} = {};\n        if (timingAst.easing) {\n          newStyleData['easing'] = timingAst.easing;\n        }\n        styleMetadata = style(newStyleData);\n      }\n      context.currentTime += timingAst.duration + timingAst.delay;\n      const /** @type {?} */ styleAst = this.visitStyle(styleMetadata, context);\n      styleAst.isEmptyStep = isEmpty;\n      styles = styleAst;\n    }\n\n    context.currentAnimateTimings = null;\n    return new AnimationAnimateAst(timingAst, styles);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitStyle(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext):\n      AnimationStyleAst {\n    const /** @type {?} */ ast = this._makeStyleAst(metadata, context);\n    this._validateStyleAst(ast, context);\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nprivate _makeStyleAst(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext):\n      AnimationStyleAst {\n    const /** @type {?} */ styles: (ɵStyleData | string)[] = [];\n    if (Array.isArray(metadata.styles)) {\n      ( /** @type {?} */((metadata.styles as(ɵStyleData | string)[]))).forEach(styleTuple => {\n        if (typeof styleTuple == 'string') {\n          if (styleTuple == AUTO_STYLE) {\n            styles.push( /** @type {?} */((styleTuple as string)));\n          } else {\n            context.errors.push(`The provided style string value ${styleTuple} is not allowed.`);\n          }\n        } else {\n          styles.push( /** @type {?} */((styleTuple as ɵStyleData)));\n        }\n      })\n    } else {\n      styles.push(metadata.styles);\n    }\n\n    let /** @type {?} */ collectedEasing: string = null;\n    styles.forEach(styleData => {\n      if (isObject(styleData)) {\n        const /** @type {?} */ styleMap = /** @type {?} */(( styleData as ɵStyleData));\n        const /** @type {?} */ easing = styleMap['easing'];\n        if (easing) {\n          collectedEasing = /** @type {?} */(( easing as string));\n          delete styleMap['easing'];\n        }\n      }\n    });\n    return new AnimationStyleAst(styles, collectedEasing, metadata.offset);\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nprivate _validateStyleAst(ast: AnimationStyleAst, context: AnimationAstBuilderContext): void {\n    const /** @type {?} */ timings = context.currentAnimateTimings;\n    let /** @type {?} */ endTime = context.currentTime;\n    let /** @type {?} */ startTime = context.currentTime;\n    if (timings && startTime > 0) {\n      startTime -= timings.duration + timings.delay;\n    }\n\n    ast.styles.forEach(tuple => {\n      if (typeof tuple == 'string') return;\n\n      Object.keys(tuple).forEach(prop => {\n        const /** @type {?} */ collectedStyles = context.collectedStyles[context.currentQuerySelector];\n        const /** @type {?} */ collectedEntry = collectedStyles[prop];\n        let /** @type {?} */ updateCollectedStyle = true;\n        if (collectedEntry) {\n          if (startTime != endTime && startTime >= collectedEntry.startTime &&\n              endTime <= collectedEntry.endTime) {\n            context.errors.push(\n                `The CSS property \"${prop}\" that exists between the times of \"${collectedEntry.startTime}ms\" and \"${collectedEntry.endTime}ms\" is also being animated in a parallel animation between the times of \"${startTime}ms\" and \"${endTime}ms\"`);\n            updateCollectedStyle = false;\n          }\n\n          // we always choose the smaller start time value since we\n          // want to have a record of the entire animation window where\n          // the style property is being animated in between\n          startTime = collectedEntry.startTime;\n        }\n\n        if (updateCollectedStyle) {\n          collectedStyles[prop] = {startTime, endTime};\n        }\n\n        if (context.locals) {\n          validateStyleLocals(tuple[prop], context.locals, context.errors);\n        }\n      });\n    });\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitKeyframeSequence(\n      metadata: AnimationKeyframesSequenceMetadata,\n      context: AnimationAstBuilderContext): AnimationKeyframesSequenceAst {\n    if (!context.currentAnimateTimings) {\n      context.errors.push(`keyframes() must be placed inside of a call to animate()`);\n      return;\n    }\n\n    const /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;\n\n    let /** @type {?} */ totalKeyframesWithOffsets = 0;\n    const /** @type {?} */ offsets: number[] = [];\n    let /** @type {?} */ offsetsOutOfOrder = false;\n    let /** @type {?} */ keyframesOutOfRange = false;\n    let /** @type {?} */ previousOffset: number = 0;\n\n    const /** @type {?} */ keyframes: AnimationStyleAst[] = metadata.steps.map(styles => {\n      const /** @type {?} */ style = this._makeStyleAst(styles, context);\n      let /** @type {?} */ offsetVal: number = style.offset != null ? style.offset : consumeOffset(style.styles);\n      let /** @type {?} */ offset: number = 0;\n      if (offsetVal != null) {\n        totalKeyframesWithOffsets++;\n        offset = style.offset = offsetVal;\n      }\n      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n      previousOffset = offset;\n      offsets.push(offset);\n      return style;\n    });\n\n    if (keyframesOutOfRange) {\n      context.errors.push(`Please ensure that all keyframe offsets are between 0 and 1`);\n    }\n\n    if (offsetsOutOfOrder) {\n      context.errors.push(`Please ensure that all keyframe offsets are in order`);\n    }\n\n    const /** @type {?} */ length = metadata.steps.length;\n    let /** @type {?} */ generatedOffset = 0;\n    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n      context.errors.push(`Not all style() steps within the declared keyframes() contain offsets`);\n    } else if (totalKeyframesWithOffsets == 0) {\n      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n    }\n\n    const /** @type {?} */ limit = length - 1;\n    const /** @type {?} */ currentTime = context.currentTime;\n    const /** @type {?} */ animateDuration = context.currentAnimateTimings.duration;\n    keyframes.forEach((kf, i) => {\n      const /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\n      const /** @type {?} */ durationUpToThisFrame = offset * animateDuration;\n      context.currentTime =\n          currentTime + context.currentAnimateTimings.delay + durationUpToThisFrame;\n      context.currentAnimateTimings.duration = durationUpToThisFrame;\n      this._validateStyleAst(kf, context);\n      kf.offset = offset;\n    });\n\n    return new AnimationKeyframesSequenceAst(keyframes);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitReference(metadata: AnimationReferenceMetadata, context: AnimationAstBuilderContext):\n      AnimationReferenceAst {\n    const /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    return new AnimationReferenceAst(entry, normalizeLocals(metadata.locals));\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitAnimateChild(metadata: AnimationAnimateChildMetadata, context: AnimationAstBuilderContext):\n      AnimationAnimateChildAst {\n    let /** @type {?} */ animationArg: AnimationReferenceMetadata = null;\n    let /** @type {?} */ timings: AnimateTimings = null;\n    let /** @type {?} */ locals: {[key: string]: any} = null;\n    const /** @type {?} */ args = metadata.args;\n    switch (countArgs(args)) {\n      case 0:\n        // animateChild()\n        context.depCount++;\n        break;\n      case 1:\n        // animateChild(string|definition|number)\n        const /** @type {?} */ arg = args[0];\n        if (typeof arg == 'string' || arg >= 0) {\n          // animateChild(string|number)\n          context.depCount++;\n          timings = resolveTimingValue( /** @type {?} */((arg as string | number)), context.errors);\n        } else if (( /** @type {?} */((arg as AnimationMetadata))).type == AnimationMetadataType.Definition) {\n          // animateChild(definition)\n          animationArg = /** @type {?} */(( arg as AnimationReferenceMetadata));\n        }\n        break;\n      case 2:\n        animationArg = /** @type {?} */(( args[0] as any));\n        if (animationArg['type']) {\n          // animateChild(definition, locals)\n          animationArg = /** @type {?} */(( args[0] as AnimationReferenceMetadata));\n          locals = normalizeLocals( /** @type {?} */((args[1] as{[key: string]: any})));\n        } else {\n          // animateChild(string|number, definition)\n          timings = resolveTimingValue( /** @type {?} */((args[0] as string | number)), context.errors);\n          animationArg = /** @type {?} */(( args[1] as AnimationReferenceMetadata));\n        }\n        break;\n      default:\n        // animateChild(string|number, definition, locals)\n        timings = resolveTimingValue( /** @type {?} */((args[0] as string | number)), context.errors);\n        animationArg = /** @type {?} */(( args[1] as AnimationReferenceMetadata));\n        locals = normalizeLocals( /** @type {?} */((args[2] as{[key: string]: any})));\n        break;\n    }\n    const /** @type {?} */ animation = animationArg ? this.visitReference(animationArg, context) : null;\n    return new AnimationAnimateChildAst(timings, animation, locals);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitQuery(metadata: AnimationQueryMetadata, context: AnimationAstBuilderContext):\n      AnimationQueryAst {\n    const /** @type {?} */ parentSelector = context.currentQuerySelector;\n\n    context.queryCount++;\n    context.currentQuery = metadata;\n    const [selector, includeSelf] = normalizeSelector(metadata.selector);\n    context.currentQuerySelector =\n        parentSelector.length ? (parentSelector + ' ' + selector) : selector;\n    getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});\n\n    const /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    context.currentQuery = null;\n    context.currentQuerySelector = parentSelector;\n    return new AnimationQueryAst(selector, metadata.multi, includeSelf, entry);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitStagger(metadata: AnimationStaggerMetadata, context: AnimationAstBuilderContext):\n      AnimationStaggerAst {\n    if (!context.currentQuery || !context.currentQuery.multi) {\n      context.errors.push(`stagger() can only be used inside of queryAll()`);\n    }\n    let /** @type {?} */ timings: AnimateTimings;\n    let /** @type {?} */ animation: AnimationAst;\n    switch (countArgs(metadata.args)) {\n      case 1:\n        // stagger(animation)\n        timings = /** @type {?} */(( { duration: 0, delay: 0, easing: 'full' } as AnimateTimings));\n        animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.args[0]), context);\n        break;\n      default:\n        // stagger(timing, animation)\n        timings = resolveTimingValue( /** @type {?} */((metadata.args[0] as string)), context.errors, true);\n        animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.args[1]), context);\n        break;\n    }\n    return new AnimationStaggerAst(timings, animation);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitWait(metadata: AnimationWaitMetadata, context: AnimationAstBuilderContext):\n      AnimationWaitAst {\n    const /** @type {?} */ timings = resolveTimingValue(metadata.delay, context.errors);\n    if (timings.duration < 0) {\n      context.errors.push('Negative wait delays are not supported');\n    }\n    if (timings.duration && timings.delay) {\n      context.errors.push('Wait delays can only support a single timing value');\n    }\n    if (timings.easing) {\n      context.errors.push('Wait delays cannot support easing values');\n    }\n\n    const /** @type {?} */ animation = metadata.animation ?\n        visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context) :\n        null;\n    return new AnimationWaitAst(timings.duration, animation);\n  }\n}\n/**\n * @param {?} selector\n * @return {?}\n */\nfunction normalizeSelector(selector: string): [string, boolean] {\n  const /** @type {?} */ hasAmpersand = selector.split(/\\s*,\\s*/).find(token => token == '&') ? true : false;\n  if (hasAmpersand) {\n    selector = selector.replace(/\\s*&\\s*,?/g, '');\n  }\n\n  selector = selector.replace(ENTER_TOKEN_REGEX, ENTER_SELECTOR)\n                 .replace(LEAVE_TOKEN_REGEX, LEAVE_SELECTOR)\n                 .replace(/@\\*/g, NG_TRIGGER_SELECTOR)\n                 .replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.substr(1))\n                 .replace(/:animating/g, NG_ANIMATING_SELECTOR);\n\n  return [selector, hasAmpersand];\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction normalizeLocals(obj: {[key: string]: any}): {[key: string]: any} {\n  return obj ? copyObj(obj) : null;\n}\n/**\n * @param {?} args\n * @return {?}\n */\nfunction countArgs(args: any[]): number {\n  return args.reduce((count, arg) => (arg != null ? 1 : 0) + count, 0);\n}\n\nexport type StyleTimeTuple = {\n  startTime: number; endTime: number;\n};\nexport class AnimationAstBuilderContext {\npublic queryCount: number = 0;\npublic depCount: number = 0;\npublic currentTransition: AnimationTransitionMetadata;\npublic currentQuery: AnimationQueryMetadata;\npublic currentQuerySelector: string;\npublic currentAnimateTimings: AnimationTimingAst;\npublic currentTime: number = 0;\npublic collectedStyles: {[selectorName: string]: {[propName: string]: StyleTimeTuple}} = {};\npublic locals: {[varName: string]: string | number | boolean} = null;\n/**\n * @param {?} errors\n */\nconstructor(public errors: any[]) {\n    // this is for the rootElement's selector\n    const ROOT_SELECTOR = '';\n    this.currentQuerySelector = ROOT_SELECTOR;\n    this.collectedStyles[ROOT_SELECTOR] = {};\n  }\n}\n\nfunction AnimationAstBuilderContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationAstBuilderContext.prototype.queryCount;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.depCount;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentTransition;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentQuery;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentQuerySelector;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentTime;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.collectedStyles;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.locals;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.errors;\n}\n\n/**\n * @param {?} styles\n * @return {?}\n */\nfunction consumeOffset(styles: ɵStyleData | string | (ɵStyleData | string)[]): number {\n  let /** @type {?} */ offset: number = null;\n  if (typeof styles == 'string') return offset;\n\n  if (Array.isArray(styles)) {\n    styles.forEach(styleTuple => {\n      if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {\n        const /** @type {?} */ obj = /** @type {?} */(( styleTuple as ɵStyleData));\n        offset = parseFloat( /** @type {?} */((obj['offset'] as string)));\n        delete obj['offset'];\n      }\n    });\n  } else if (isObject(styles) && styles.hasOwnProperty('offset')) {\n    const /** @type {?} */ obj = /** @type {?} */(( styles as ɵStyleData));\n    offset = parseFloat( /** @type {?} */((obj['offset'] as string)));\n    delete obj['offset'];\n  }\n  return offset;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isObject(value: any): boolean {\n  return !Array.isArray(value) && typeof value == 'object';\n}\n/**\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nfunction constructTimingAst(value: string | number | AnimateTimings, errors: any[]) {\n  let /** @type {?} */ timings: AnimateTimings = null;\n  if (value.hasOwnProperty('duration')) {\n    timings = /** @type {?} */(( value as AnimateTimings));\n  } else if (typeof value == 'number') {\n    const /** @type {?} */ duration = resolveTimingValue( /** @type {?} */((value as number)), errors).duration;\n    return new AnimationTimingAst( /** @type {?} */((value as number)), 0, '');\n  }\n\n  const /** @type {?} */ strValue = /** @type {?} */(( value as string));\n  const /** @type {?} */ isDynamic = strValue.split(/\\s+/).some(v => v.charAt(0) == '$');\n  if (isDynamic) {\n    return new DynamicAnimationTimingAst(strValue);\n  }\n\n  timings = timings || resolveTimingValue(strValue, errors);\n  return new AnimationTimingAst(timings.duration, timings.delay, timings.easing);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\nexport class ElementInstructionMap {\nprivate _map = new Map<any, AnimationTimelineInstruction[]>();\n/**\n * @param {?} element\n * @return {?}\n */\nconsume(element: any): AnimationTimelineInstruction[] {\n    let /** @type {?} */ instructions = this._map.get(element);\n    if (instructions) {\n      this._map.delete(element);\n    } else {\n      instructions = [];\n    }\n    return instructions;\n  }\n/**\n * @param {?} element\n * @param {?} instructions\n * @return {?}\n */\nappend(element: any, instructions: AnimationTimelineInstruction[]) {\n    let /** @type {?} */ existingInstructions = this._map.get(element);\n    if (!existingInstructions) {\n      this._map.set(element, existingInstructions = []);\n    }\n    existingInstructions.push(...instructions);\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nhas(element: any): boolean { return this._map.has(element); }\n/**\n * @return {?}\n */\nclear() { this._map.clear(); }\n}\n\nfunction ElementInstructionMap_tsickle_Closure_declarations() {\n/** @type {?} */\nElementInstructionMap.prototype._map;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationPlayer, NoopAnimationPlayer} from '@angular/animations';\n\n\n\n/**\n * @experimental\n */\nexport class NoopAnimationDriver implements AnimationDriver {\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): AnimationPlayer {\n    return new NoopAnimationPlayer();\n  }\n}\n\n/**\n * @experimental\n */\nexport abstract class AnimationDriver {\n  static NOOP: AnimationDriver = new NoopAnimationDriver();\n\n  abstract computeStyle(element: any, prop: string, defaultValue?: string): string;\n\n  abstract animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers?: any[]): any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\n\nexport interface AnimationTransitionInstruction extends AnimationEngineInstruction {\n  element: any;\n  triggerName: string;\n  isRemovalTransition: boolean;\n  fromState: string;\n  fromStyles: ɵStyleData;\n  toState: string;\n  toStyles: ɵStyleData;\n  timelines: AnimationTimelineInstruction[];\n  queriedElements: any[];\n  preStyleProps: Map<any, {[prop: string]: boolean}>;\n  postStyleProps: Map<any, {[prop: string]: boolean}>;\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} isRemovalTransition\n * @param {?} fromStyles\n * @param {?} toStyles\n * @param {?} timelines\n * @param {?} queriedElements\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @return {?}\n */\nexport function createTransitionInstruction(\n    element: any, triggerName: string, fromState: string, toState: string,\n    isRemovalTransition: boolean, fromStyles: ɵStyleData, toStyles: ɵStyleData,\n    timelines: AnimationTimelineInstruction[], queriedElements: any[],\n    preStyleProps: Map<any, {[prop: string]: boolean}>,\n    postStyleProps: Map<any, {[prop: string]: boolean}>): AnimationTransitionInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TransitionAnimation,\n    element,\n    triggerName,\n    isRemovalTransition,\n    fromState,\n    fromStyles,\n    toState,\n    toStyles,\n    timelines,\n    queriedElements,\n    preStyleProps,\n    postStyleProps\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\n\nexport interface AnimationTimelineInstruction extends AnimationEngineInstruction {\n  element: any;\n  keyframes: ɵStyleData[];\n  preStyleProps: string[];\n  postStyleProps: string[];\n  duration: number;\n  delay: number;\n  totalTime: number;\n  easing: string;\n  stretchStartingKeyframe?: boolean;\n  subTimeline: boolean;\n}\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @param {?=} subTimeline\n * @return {?}\n */\nexport function createTimelineInstruction(\n    element: any, keyframes: ɵStyleData[], preStyleProps: string[], postStyleProps: string[],\n    duration: number, delay: number, easing: string,\n    subTimeline: boolean = false): AnimationTimelineInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TimelineAnimation,\n    element,\n    keyframes,\n    preStyleProps,\n    postStyleProps,\n    duration,\n    delay,\n    totalTime: duration + delay, easing, subTimeline\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationAnimateChildMetadata, AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationQueryMetadata, AnimationReferenceMetadata, AnimationSequenceMetadata, AnimationStaggerMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, AnimationTriggerMetadata, AnimationWaitMetadata} from '@angular/animations';\n\nexport interface AnimationDslVisitor {\n  visitTrigger(ast: AnimationTriggerMetadata, context: any): any;\n  visitState(ast: AnimationStateMetadata, context: any): any;\n  visitTransition(ast: AnimationTransitionMetadata, context: any): any;\n  visitSequence(ast: AnimationSequenceMetadata, context: any): any;\n  visitGroup(ast: AnimationGroupMetadata, context: any): any;\n  visitAnimate(ast: AnimationAnimateMetadata, context: any): any;\n  visitStyle(ast: AnimationStyleMetadata, context: any): any;\n  visitKeyframeSequence(ast: AnimationKeyframesSequenceMetadata, context: any): any;\n  visitReference(ast: AnimationReferenceMetadata, context: any): any;\n  visitAnimateChild(ast: AnimationAnimateChildMetadata, context: any): any;\n  visitQuery(ast: AnimationQueryMetadata, context: any): any;\n  visitStagger(ast: AnimationStaggerMetadata, context: any): any;\n  visitWait(ast: AnimationWaitMetadata, context: any): any;\n}\n/**\n * @param {?} visitor\n * @param {?} node\n * @param {?} context\n * @return {?}\n */\nexport function visitAnimationNode(\n    visitor: AnimationDslVisitor, node: AnimationMetadata, context: any) {\n  switch (node.type) {\n    case AnimationMetadataType.Trigger:\n      return visitor.visitTrigger( /** @type {?} */((node as AnimationTriggerMetadata)), context);\n    case AnimationMetadataType.State:\n      return visitor.visitState( /** @type {?} */((node as AnimationStateMetadata)), context);\n    case AnimationMetadataType.Transition:\n      return visitor.visitTransition( /** @type {?} */((node as AnimationTransitionMetadata)), context);\n    case AnimationMetadataType.Sequence:\n      return visitor.visitSequence( /** @type {?} */((node as AnimationSequenceMetadata)), context);\n    case AnimationMetadataType.Group:\n      return visitor.visitGroup( /** @type {?} */((node as AnimationGroupMetadata)), context);\n    case AnimationMetadataType.Animate:\n      return visitor.visitAnimate( /** @type {?} */((node as AnimationAnimateMetadata)), context);\n    case AnimationMetadataType.KeyframeSequence:\n      return visitor.visitKeyframeSequence( /** @type {?} */((node as AnimationKeyframesSequenceMetadata)), context);\n    case AnimationMetadataType.Style:\n      return visitor.visitStyle( /** @type {?} */((node as AnimationStyleMetadata)), context);\n    case AnimationMetadataType.Definition:\n      return visitor.visitReference( /** @type {?} */((node as AnimationReferenceMetadata)), context);\n    case AnimationMetadataType.AnimateChild:\n      return visitor.visitAnimateChild( /** @type {?} */((node as AnimationAnimateChildMetadata)), context);\n    case AnimationMetadataType.Query:\n      return visitor.visitQuery( /** @type {?} */((node as AnimationQueryMetadata)), context);\n    case AnimationMetadataType.Stagger:\n      return visitor.visitStagger( /** @type {?} */((node as AnimationStaggerMetadata)), context);\n    case AnimationMetadataType.Wait:\n      return visitor.visitWait( /** @type {?} */((node as AnimationWaitMetadata)), context);\n    default:\n      throw new Error(`Unable to resolve animation metadata node #${node.type}`);\n  }\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const ANY_STATE = '*';\nexport declare type TransitionMatcherFn = (fromState: any, toState: any) => boolean;\n/**\n * @param {?} transitionValue\n * @param {?} errors\n * @return {?}\n */\nexport function parseTransitionExpr(\n    transitionValue: string | TransitionMatcherFn, errors: string[]): TransitionMatcherFn[] {\n  const /** @type {?} */ expressions: TransitionMatcherFn[] = [];\n  if (typeof transitionValue == 'string') {\n    ( /** @type {?} */((<string>transitionValue)))\n        .split(/\\s*,\\s*/)\n        .forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push( /** @type {?} */((<TransitionMatcherFn>transitionValue)));\n  }\n  return expressions;\n}\n/**\n * @param {?} eventStr\n * @param {?} expressions\n * @param {?} errors\n * @return {?}\n */\nfunction parseInnerTransitionStr(\n    eventStr: string, expressions: TransitionMatcherFn[], errors: string[]) {\n  if (eventStr[0] == ':') {\n    eventStr = parseAnimationAlias(eventStr, errors);\n  }\n  const /** @type {?} */ match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(`The provided transition expression \"${eventStr}\" is not supported`);\n    return expressions;\n  }\n\n  const /** @type {?} */ fromState = match[1];\n  const /** @type {?} */ separator = match[2];\n  const /** @type {?} */ toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n\n  const /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n}\n/**\n * @param {?} alias\n * @param {?} errors\n * @return {?}\n */\nfunction parseAnimationAlias(alias: string, errors: string[]): string {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    default:\n      errors.push(`The transition alias value \"${alias}\" is not supported`);\n      return '* => *';\n  }\n}\n/**\n * @param {?} lhs\n * @param {?} rhs\n * @return {?}\n */\nfunction makeLambdaFromStates(lhs: string, rhs: string): TransitionMatcherFn {\n  return (fromState: any, toState: any): boolean => {\n    const /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    const /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;\n    return lhsMatch && rhsMatch;\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationEvent, AnimationPlayer, NoopAnimationPlayer, PRE_STYLE, ɵAnimationGroupPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\n/**\n * @param {?} players\n * @return {?}\n */\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n/**\n * @param {?} driver\n * @param {?} normalizer\n * @param {?} element\n * @param {?} keyframes\n * @param {?} preStyles\n * @param {?} postStyles\n * @return {?}\n */\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: ɵStyleData[], preStyles: ɵStyleData, postStyles: ɵStyleData): ɵStyleData[] {\n  const /** @type {?} */ errors: string[] = [];\n  const /** @type {?} */ normalizedKeyframes: ɵStyleData[] = [];\n  let /** @type {?} */ previousOffset = -1;\n  let /** @type {?} */ previousKeyframe: ɵStyleData = null;\n  keyframes.forEach(kf => {\n    const /** @type {?} */ offset = /** @type {?} */(( kf['offset'] as number));\n    const /** @type {?} */ isSameOffset = offset == previousOffset;\n    const /** @type {?} */ normalizedKeyframe: ɵStyleData = isSameOffset ? previousKeyframe : {};\n    Object.keys(kf).forEach(prop => {\n      let /** @type {?} */ normalizedProp = prop;\n      let /** @type {?} */ normalizedValue = kf[prop];\n      if (normalizedValue == PRE_STYLE) {\n        normalizedValue = preStyles[prop];\n      } else if (normalizedValue == AUTO_STYLE) {\n        normalizedValue = postStyles[prop];\n      } else if (prop != 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(prop, errors);\n        normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, kf[prop], errors);\n      }\n      normalizedKeyframe[normalizedProp] = normalizedValue;\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    const /** @type {?} */ LINE_START = '\\n - ';\n    throw new Error(\n        `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n  }\n\n  return normalizedKeyframes;\n}\n/**\n * @param {?} player\n * @param {?} eventName\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(\n          () => { callback(event && copyAnimationEvent(event, 'start', player.totalTime)); });\n      break;\n    case 'done':\n    case 'onDone':\n      player.onDone(\n          () => { callback(event && copyAnimationEvent(event, 'done', player.totalTime)); });\n      break;\n    case 'destroy':\n      player.onDestroy(\n          () => { callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)); });\n      break;\n  }\n}\n/**\n * @param {?} e\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @return {?}\n */\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName?: string, totalTime?: number): AnimationEvent {\n  return makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime);\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @return {?}\n */\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = null,\n    totalTime: number = null): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime};\n}\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} defaultValue\n * @return {?}\n */\nexport function getOrSetAsInMap(\n    map: Map<any, any>| {[key: string]: any}, key: any, defaultValue: any) {\n  let /** @type {?} */ value: any;\n  if (map instanceof Map) {\n    value = map.get(key);\n    if (!value) {\n      map.set(key, value = defaultValue);\n    }\n  } else {\n    value = map[key];\n    if (!value) {\n      value = map[key] = defaultValue;\n    }\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimateTimings, AnimationMetadata, sequence, ɵStyleData} from '@angular/animations';\n\nexport const /** @type {?} */ ONE_SECOND = 1000;\n\nexport const /** @type {?} */ ENTER_CLASSNAME = 'ng-enter';\nexport const /** @type {?} */ LEAVE_CLASSNAME = 'ng-leave';\nexport const /** @type {?} */ ENTER_SELECTOR = '.ng-enter';\nexport const /** @type {?} */ LEAVE_SELECTOR = '.ng-leave';\nexport const /** @type {?} */ NG_TRIGGER_CLASSNAME = 'ng-trigger';\nexport const /** @type {?} */ NG_TRIGGER_SELECTOR = '.ng-trigger';\nexport const /** @type {?} */ NG_ANIMATING_CLASSNAME = 'ng-animating';\nexport const /** @type {?} */ NG_ANIMATING_SELECTOR = '.ng-animating';\n/**\n * @param {?} timings\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nexport function resolveTimingValue(\n    timings: string | number | AnimateTimings, errors: any[], allowNegativeValues?: boolean) {\n  return timings.hasOwnProperty('duration') ? /** @type {?} */((\n      <AnimateTimings>timings)) :\n      parseTimeExpression( /** @type {?} */((<string|number>timings)), errors, allowNegativeValues);\n}\n/**\n * @param {?} exp\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nfunction parseTimeExpression(\n    exp: string | number, errors: string[], allowNegativeValues?: boolean): AnimateTimings {\n  const /** @type {?} */ regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let /** @type {?} */ duration: number;\n  let /** @type {?} */ delay: number = 0;\n  let /** @type {?} */ easing: string = null;\n  if (typeof exp === 'string') {\n    const /** @type {?} */ matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(`The provided timing value \"${exp}\" is invalid.`);\n      return {duration: 0, delay: 0, easing: null};\n    }\n\n    let /** @type {?} */ durationMatch = parseFloat(matches[1]);\n    const /** @type {?} */ durationUnit = matches[2];\n    if (durationUnit == 's') {\n      durationMatch *= ONE_SECOND;\n    }\n    duration = Math.floor(durationMatch);\n\n    const /** @type {?} */ delayMatch = matches[3];\n    const /** @type {?} */ delayUnit = matches[4];\n    if (delayMatch != null) {\n      let /** @type {?} */ delayVal: number = parseFloat(delayMatch);\n      if (delayUnit != null && delayUnit == 's') {\n        delayVal *= ONE_SECOND;\n      }\n      delay = Math.floor(delayVal);\n    }\n\n    const /** @type {?} */ easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = /** @type {?} */(( <number>exp));\n  }\n\n  if (!allowNegativeValues) {\n    let /** @type {?} */ containsErrors = false;\n    let /** @type {?} */ startIndex = errors.length;\n    if (duration < 0) {\n      errors.push(`Duration values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (delay < 0) {\n      errors.push(`Delay values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (containsErrors) {\n      errors.splice(startIndex, 0, `The provided timing value \"${exp}\" is invalid.`);\n    }\n  }\n\n  return {duration, delay, easing};\n}\n/**\n * @param {?} obj\n * @param {?=} destination\n * @return {?}\n */\nexport function copyObj(\n    obj: {[key: string]: any}, destination: {[key: string]: any} = {}): {[key: string]: any} {\n  Object.keys(obj).forEach(prop => { destination[prop] = obj[prop]; });\n  return destination;\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nexport function normalizeStyles(styles: ɵStyleData | ɵStyleData[]): ɵStyleData {\n  const /** @type {?} */ normalizedStyles: ɵStyleData = {};\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, false, normalizedStyles));\n  } else {\n    copyStyles(styles, false, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n/**\n * @param {?} styles\n * @param {?} readPrototype\n * @param {?=} destination\n * @return {?}\n */\nexport function copyStyles(\n    styles: ɵStyleData, readPrototype: boolean, destination: ɵStyleData = {}): ɵStyleData {\n  if (readPrototype) {\n    // we make use of a for-in loop so that the\n    // prototypically inherited properties are\n    // revealed from the backFill map\n    for (let /** @type {?} */ prop in styles) {\n      destination[prop] = styles[prop];\n    }\n  } else {\n    copyObj(styles, destination);\n  }\n  return destination;\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function setStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => element.style[prop] = styles[prop]);\n  }\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function eraseStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      element.style[prop] = '';\n    });\n  }\n}\n/**\n * @param {?} steps\n * @return {?}\n */\nexport function normalizeAnimationEntry(steps: AnimationMetadata | AnimationMetadata[]):\n    AnimationMetadata {\n  if (Array.isArray(steps)) {\n    if (steps.length == 1) return steps[0];\n    return sequence(steps);\n  }\n  return /** @type {?} */(( steps as AnimationMetadata));\n}\n\n// this is a naive approach to search/replace\n// TODO: check to see that transforms are not effected\nconst /** @type {?} */ SIMPLE_STYLE_INTERPOLATION_REGEX = /\\$\\w+/g;\nconst /** @type {?} */ ADVANCED_STYLE_INTERPOLATION_REGEX = /\\$\\{([-\\w\\s]+)\\}/g;\n/**\n * @param {?} value\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nexport function validateStyleLocals(\n    value: string | number, locals: {[varName: string]: string | number | boolean}, errors: any[]) {\n  if (typeof value == 'string') {\n    matchAndValidate(SIMPLE_STYLE_INTERPOLATION_REGEX, 1, 0, /** @type {?} */(( value as string)), locals, errors);\n    matchAndValidate(ADVANCED_STYLE_INTERPOLATION_REGEX, 2, 1, /** @type {?} */(( value as string)), locals, errors);\n  }\n}\n/**\n * @param {?} regex\n * @param {?} prefixLength\n * @param {?} suffixLength\n * @param {?} str\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nfunction matchAndValidate(\n    regex: RegExp, prefixLength: number, suffixLength: number, str: string,\n    locals: {[varName: string]: string | number | boolean}, errors: any[]) {\n  const /** @type {?} */ matches = str.toString().match(regex);\n  if (matches) {\n    matches.forEach(varName => {\n      varName =\n          varName.substring(prefixLength, varName.length - suffixLength);  // drop the $ or ${}\n      if (!locals.hasOwnProperty(varName)) {\n        errors.push(\n            `Unable to resolve the local animation variable $${varName} in the given list of values`);\n      }\n    });\n  }\n}\n/**\n * @param {?} value\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nexport function interpolateStyleLocals(\n    value: string | number, locals: {[varName: string]: string | number | boolean},\n    errors: any[]): string {\n  let /** @type {?} */ str = value.toString();\n  str = matchAndReplace(SIMPLE_STYLE_INTERPOLATION_REGEX, 1, 0, str, locals, errors);\n  str = matchAndReplace(ADVANCED_STYLE_INTERPOLATION_REGEX, 2, 1, str, locals, errors);\n  return str;\n}\n/**\n * @param {?} regex\n * @param {?} prefixLength\n * @param {?} suffixLength\n * @param {?} str\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nfunction matchAndReplace(\n    regex: RegExp, prefixLength: number, suffixLength: number, str: string,\n    locals: {[varName: string]: string | number | boolean}, errors: any[]) {\n  return str.replace(regex, varName => {\n    varName = varName.substring(prefixLength, varName.length - suffixLength);  // drop the $ or ${}\n    let /** @type {?} */ localVal = locals[varName];\n    // this means that the value was never overidden by the data passed in by the user\n    if (localVal === true) {\n      errors.push(`Please provide a value for the animation variable $${varName}`);\n      localVal = '';\n    }\n    return localVal.toString();\n  });\n}\n/**\n * @param {?} iterator\n * @return {?}\n */\nexport function iteratorToArray(iterator: any): any[] {\n  const /** @type {?} */ arr: any[] = [];\n  let /** @type {?} */ item = iterator.next();\n  while (!item.done) {\n    arr.push(item.value);\n    item = iterator.next();\n  }\n  return arr;\n}\n"],"names":["triggerName","instruction","rootElement","element","targetNameSpaceId","isRemovalTransition","undefined","namespaceId","targetTriggerName","timelines","map","timelineInstruction","isQueriedElement","players","getOrSetAsInMap","allPreviousPlayersMap","_this","this","allQueriedPlayers","allConsumedElements","Set","allNewPlayers","_angular_animations","NoopAnimationPlayer","previousPlayers","EMPTY_PLAYER_ARRAY","has","_previousPlayers","p","getRealPlayer","postStyles","postStylesMap","get","keyframes","normalizeKeyframes","_driver","_normalizer","preStyles","player","_buildPlayer","subTimeline","skippedPlayersMap","push","wrappedPlayer","TransitionAnimationPlayer","setRealPlayer","forEach","playersByQueriedElement","prototype","_player","onDone","fn","onStart","destroy","DomAnimationEngine","registerTrigger","componentId","hostElement","name","metadata","cacheKey","trigger","_triggerCache","_transitionEngine","listen","eventName","eventPhase","callback","flush","concat","_timelineEngine","DEFAULT_STATE_VALUE$1","DEFAULT_STATE_STYLES","NoopAnimationEngine","_super","setProperty","property","value","charAt","namespacedName","storageProp","makeStorageProp","oldValue","_changes","newValue","triggerStateStyles","_triggerStyles","fromStateStyles","listeners","_listeners","tuple","handleListener","listener","data","phase","event","makeAnimationEvent$1","onStartCallbacks","onDoneCallbacks","change","_flaggedRemovals","Array","from","keys","listenersToKeep","filter","l","doRemove","length","set","clear","WebAnimationsPlayer","options","_onDoneFns","_onStartFns","_onDestroyFns","_initialized","_finished","_started","_destroyed","time","parentPlayer","_duration","_delay","previousStyles","_onFinish","init","styles","copyStyles","previousStyleProps","Object","missingStyleProps_1","prop","startingKeyframe_1","hasOwnProperty","self_1","i","_loop_1","_triggerWebAnimation","onDestroy","hasStarted","finish","reset","play","setPosition","currentTime","getPosition","configurable","beforeDestroy","_finalKeyframe","fill","delay","easing","playerOptions","TimelineBuilder","getFinalKeyframe","_keyframes","duration","defineProperty","properties","details0","_styleSummary","details1","timeline","buildKeyframes","preStyleProps","postStyleProps","PRE_STYLE","keyframe","finalKeyframe","add","AUTO_STYLE","SubTimelineBuilder","containsAnimation","_stretchStartingKeyframe","limit","kf","timeAtKeyframe","oldOffset","roundOffset","totalTime","newKeyframes","Animation","buildTimelines","startingStyles","destinationStyles","locals","subInstructions","start","isArray","normalizeStyles","dest","ElementInstructionMap","Error","errorMessage","WebAnimationsStyleNormalizer","normalizeStyleValue","userProvidedProperty","normalizedProperty","errors","unit","strVal","toString","trim","DIMENSIONAL_PROP_MAP","valAndSuffixMatch","match","split","AnimationTransitionFactory","build","currentState","nextState","animationLocals","ast","backupStateStyles","_stateStyles","currentStateStyles","nextStateStyles","buildAnimationTimelines","animation","join","preStyleMap","Map","postStyleMap","queriedElements","tl","elm","preProps","postProps","AnimationTrigger","transitionFactories","states","obj","style","styleTuple","TimelineAnimationEngine","create","id","instructions","_animations","autoStylesMap","EMPTY_INSTRUCTION_MAP","inst","computeStyle","optimizeGroupPlayer","_playersById","command","args","register","_getPlayer","pause","restart","StateValue","input","absorbValues","values","AnimationTransitionNamespace","_triggers","isTriggerEventValid","triggersWithStates","_engine","statesByElement","afterFlush","defaultToFallback","_getTrigger","document","body","contains","classList","NG_TRIGGER_CLASSNAME","fromState","toState","isObj","playersOnElement","queued","transition","matchTransition","isFallbackTransition","fallbackTransition","totalQueuedPlayers","_queue","NG_ANIMATING_CLASSNAME","remove","index","indexOf","splice","playersByElement","_destroyInnerNodes","context","animate","listToArray","querySelectorAll","NG_TRIGGER_SELECTOR","_hostClassName","innerNs","namespacesByHostElement","removeNode","doNotRecurse","engine","LEAVE_CLASSNAME","childElementCount","triggerStates","players_1","VOID_VALUE","destroyInnerAnimations","_onElementDestroy","currentPlayers","containsPotentialParentTransition","_elementListeners","visitedTriggers_1","DEFAULT_STATE_VALUE","queuedRemovals","insertNode","parent","drainQueuedTransitions","entry","destroyed","baseEvent","makeAnimationEvent","listenOnPlayer","markedForDestroy","sort","a","b","d0","d1","find","containsData","TransitionAnimationEngine","newlyInserted","newHostElements","_namespaceLookup","_namespaceList","_flushFns","createNamespace","_balanceNamespaceList","ns","found","nextNamespace","_fetchNamespace","containerElement","stateMap","size","_whenQuietFns","quietFns_1","allEnterNodes","iteratorToArray","POTENTIAL_ENTER_CLASSNAME","enterNodes","subTimelines","skippedPlayers","allPreStyleElements","_populateEnterElements","stretchStartingKeyframe","append","queuedInstructions","stringMap","props","setVal_1","setVal","allPostStyleElements","sortedParentElements","unshift","_beforeAnimationBuild","leaveNodes","LEAVE_SELECTOR","cloakAndComputeStyles","subPlayers","innerPlayer","_buildAnimation","preStylesMap","parentHasPriority","parentPlayers","rootPlayers","eraseStyles","fromStyles","setStyles","toStyles","playersForElement","elementPlayers","parentNode","playersForThisElement","elementContainsData","_getPreviousPlayers","queriedElementPlayers","isRemovalAnimation_1","AnimationTriggerAst","visit","visitor","visitTrigger","AnimationTransitionAst","visitTransition","AnimationSequenceAst","visitSequence","AnimationGroupAst","visitGroup","AnimationStyleAst","visitStyle","AnimationKeyframesSequenceAst","visitKeyframeSequence","AnimationQueryAst","visitQuery","AnimationStaggerAst","visitStagger","AnimationTimingAst","visitTiming","LEAVE_TOKEN_REGEX","RegExp","LEAVE_TOKEN","AnimationAstBuilderVisitor","queryCount","depCount","transitions","definitions","def","type","stateDef_1","n","visitState","visitAnimate","timingAst","constructTimingAst","timings","currentAnimateTimings","styleMetadata","styleMetadata_1","isEmpty","newStyleData","_makeStyleAst","collectedEasing","styleData","isObject","_validateStyleAst","endTime","startTime","updateCollectedStyle","collectedEntry","MAX_KEYFRAME_OFFSET","totalKeyframesWithOffsets","offsets","offsetsOutOfOrder","keyframesOutOfRange","previousOffset","steps","style$$1","offsetVal","offset","consumeOffset","generatedOffset","animateDuration","visitAnimateChild","countArgs","arg","animationArg","normalizeLocals","parentSelector","currentQuerySelector","currentQuery","multi","visitWait","resolveTimingValue","visitAnimationNode","normalizeAnimationEntry","AnimationAstBuilderContext","ROOT_SELECTOR","existingInstructions","_map","AnimationTimelineContext","initialTimeline","parentContext","createSubContext","newTime","target","currentQueryIndex","AnimationTimelineBuilderVisitor","finalStyles","currentTimeline","innerContext","copyObj","transformIntoNewTimeline","visitReference","furthestTime","Math","max","instructionTimings","subContextCount","previousNode","s","incrementTime","snapshotCurrentStyles","innerTimeline","forwardTime","step","getCurrentStyleProperties","forwardFrame","DEFAULT_NOOP_PREVIOUS_NODE","elms","invokeQuery","selector","includeSelf","currentQueryTotal","sameElementTimeline","abs","maxTime","staggerTransformer","_elementTimelineStylesLookup","_previousKeyframe","_backFill","_currentEmptyStepKeyframe","_globalTimelineStyles","_currentKeyframe","_updateStyle","styles_1","flattenStyles","val","interpolateStyleLocals","_localTimelineStyles","deleteOrUnsetInMap","key","currentValues","delete","filterNodeClasses","rootElements","cursor","nextCursor","querySelector","matches","nextElementSibling","parentElement","driver","elements","elementPropsMap","defaultStyle","cloakVals","cloakElement","valuesMap","defaultValue","NoopAnimationDriver","createTransitionInstruction","results","allStyles","allProperties","token","makeBooleanMap","createTimelineInstruction","normalizeSelector","hasAmpersand","replace","parseFloat","node","parseTransitionExpr","transitionValue","expressions","parseInnerTransitionStr","eventStr","parseAnimationAlias","alias","normalizer","normalizedKeyframes","previousKeyframe","isSameOffset","normalizedKeyframe","normalizedProp","normalizedValue","normalizePropertyName","copyAnimationEvent","parseTimeExpression","exp","allowNegativeValues","regex","durationMatch","durationUnit","ONE_SECOND","floor","delayMatch","delayUnit","delayVal","easingVal","containsErrors","startIndex","destination","readPrototype","matchAndValidate","prefixLength","suffixLength","str","matchAndReplace","varName","iterator"],"mappings":"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"}